#!/usr/bin/env bash
set -euo pipefail

# =======================================
# @author   : parkjunhong77@gmail.com
# @title    : ssh-cmd: SSH connection manager
# @license  : Apache License 2.0
# @since    : 2025-12-09
# @desc     : support RHEL 7+/8+, Oracle Linux 7+/8+, Ubuntu 20.04+/22.04+/24.04+, CentOS 7+
# @installation :
#   1. insert 'source <path>/ssh-cmd' into ~/bin/.bashrc or ~/bin/.bash_profile for a personal usage.
#   2. copy this file to /usr/local/bin/ or any directory in $PATH for all users.
# =======================================

FILENAME="$(basename "$0")"

# ê¸°ë³¸ ì„¤ì • íŒŒì¼ ê²½ë¡œ (Default configuration file path)
DEFAULT_CONFIG_DIR="${HOME}/.ssh-cmd"
DEFAULT_CONFIG_FILE="${DEFAULT_CONFIG_DIR}/configuration"

# ì„¤ì • ë””ë ‰í† ë¦¬ / íŒŒì¼
CONFIG_DIR="${HOME}/.ssh-cmd"
CONFIG_FILE="${CONFIG_DIR}/configuration"
CONFIG_VERSION="1.0"

# masterkey (OpenSSH private key) ê¸°ë³¸ ê²½ë¡œ ë° ì‹¤ì œ ì‚¬ìš© ê²½ë¡œ
MASTERKEY_DEFAULT="${HOME}/.ssh-cmd/masterkey"
MASTERKEY_FILE="${MASTERKEY_DEFAULT}"

# í”„ë¡¬í”„íŠ¸ ë¼ë²¨ í­ (ì•„ì´ì½˜+í•„ë“œëª… ê³ ì • í­)
PROMPT_LABEL_WIDTH=32

# credential í‘œì‹œ ì œì–´ (ê¸°ë³¸: ë§ˆìŠ¤í‚¹, --show-credential/-s ë¡œ í‰ë¬¸ í‘œì‹œ)
SHOW_CREDENTIAL="false"

# =======================================
# help / usage
# =======================================

##
# ssh-cmd ì „ì²´ ì‚¬ìš©ë²•ê³¼ ì—ëŸ¬ ì •ë³´ë¥¼ ì¶œë ¥í•œë‹¤.
# Print overall usage and diagnostic error information for ssh-cmd.
#
# @param $1 {string|empty} ì—ëŸ¬/ì›ì¸ ë©”ì‹œì§€ (ì„ íƒ) / cause message (optional)
# @param $2 {int|empty} ì—ëŸ¬ ë°œìƒ ë¼ì¸ ë²ˆí˜¸ (ì„ íƒ) / line number where error occurred (optional)
#
# @return {int} í•­ìƒ 0ì„ ë°˜í™˜í•˜ì§€ë§Œ, ë³´í†µ die()ì—ì„œ í˜¸ì¶œëœ ë’¤ í”„ë¡œì„¸ìŠ¤ëŠ” exit 1ë¡œ ì¢…ë£Œë¨.
#         Always returns 0; typically invoked by die() and process exits with 1 afterwards.
##
help() {
  # $1: cause message (optional)
  # $2: line number (optional)
  if [ -n "${1:-}" ]; then
    local indent=10
    local formatl=" - %-"$indent"s: %s\n"
    local formatr=" - %"$indent"s: %s\n"
    echo
    echo "================================================================================"
    printf "$formatl" "filename" "$FILENAME"
    printf "$formatl" "line" "${2:-0}"
    printf "$formatl" "callstack"
    local idx=1
    for func in "${FUNCNAME[@]:1}"
    do
      printf "$formatr" "[$idx]" "$func"
      ((idx++))
    done
    printf "$formatl" "cause" "$1"
    echo "================================================================================"
  fi
  echo
  cat <<EOF
ì‚¬ìš©ë²• (Usage):
  ssh-cmd [global-options]               # ê¸°ë³¸: ì „ì²´ ëª©ë¡ì—ì„œ ì„ íƒ í›„ ì ‘ì†
  ssh-cmd [global-options] <expr>        # expr ë¡œ í•„í„°ë§ í›„ ì„ íƒ/ì ‘ì†
  ssh-cmd [global-options] -l|--list-all [expr]
  ssh-cmd [global-options] -a|--add-connection
  ssh-cmd [global-options] -m|--modify-connection [expr]
  ssh-cmd [global-options] -d|--delete-connection [expr]
  ssh-cmd [global-options] -mg|--move-group-connection [expr]

Global options:
  --config <file>
    - ì„¤ì • íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•©ë‹ˆë‹¤. íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ í•´ë‹¹ íŒŒì¼ì„ ì„¤ì •ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - íŒŒì¼ì´ ì—†ìœ¼ë©´ ê²½ê³  ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³  ê¸°ë³¸ ê²½ë¡œ(${DEFAULT_CONFIG_FILE})ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

  --masterkey <file>
    - 'ë¯¼ê°ì •ë³´'(username, credential) ì•”/ë³µí˜¸í™”ì— ì‚¬ìš©ë  OpenSSH private key ê²½ë¡œë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
    - ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ê°’(${MASTERKEY_DEFAULT})ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

  -s, --show-credential
    - ëª©ë¡/ë¯¸ë¦¬ë³´ê¸°ì—ì„œ credential ê°’ì„ í‰ë¬¸ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    - ê¸°ë³¸ê°’ì€ í•­ìƒ "****************" (16ê°œ ë³„í‘œ)ë¡œ ë§ˆìŠ¤í‚¹í•©ë‹ˆë‹¤.

Commands:
  -l, --list-all [expr]
    - SSH connection ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
    - ê²€ìƒ‰ì‹ expr ì´ ìˆëŠ” ê²½ìš°, expr ì— í•´ë‹¹í•˜ëŠ” connection ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.

  -a, --add-connection
    - ìƒˆë¡œìš´ SSH connection ì •ë³´ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (interactive).
    - auth_type ì´ 'key' ì¸ ê²½ìš°, key path ëŠ” í•­ìƒ "ì ˆëŒ€ê²½ë¡œ"ë¡œ ì €ì¥ë©ë‹ˆë‹¤.
    - auth_type ì´ 'password' ì¸ ê²½ìš°, connection ì €ì¥ í›„ sshpass ê°€ ì—†ìœ¼ë©´ ìë™ ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.

  -m, --modify-connection [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ì„ íƒëœ connection ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
    - ìˆ˜ì • í›„ ê²°ê³¼ connection 1ê±´ì„ í‘œ í˜•íƒœë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.

  -d, --delete-connection [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ì‚­ì œ ëŒ€ìƒ connection 1ê±´ì„ í‘œë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    - ì‚¬ìš©ìê°€ y/yes ë¡œ í™•ì¸í•˜ë©´ ì‹¤ì œë¡œ ì‚­ì œí•©ë‹ˆë‹¤.

  -mg, --move-group-connection [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ê·¸ë£¹(group) ê°’ì„ ë³€ê²½í•©ë‹ˆë‹¤.

ê¸°ë³¸ ì ‘ì† ë™ì‘:
  1) ssh-cmd
     - ì „ì²´ connection ëª©ë¡ì—ì„œ ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•´ ì ‘ì†í•©ë‹ˆë‹¤.

  2) ssh-cmd <expr>
     - <expr> ì´ "-" ë¡œ ì‹œì‘í•˜ëŠ” ì˜µì…˜ì´ ì•„ë‹ˆë©´ ê²€ìƒ‰ì‹ìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
     - expr ìœ¼ë¡œ í•„í„°ë§ í›„, ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•´ ì ‘ì†í•©ë‹ˆë‹¤.
     - auth_type ì´ password ì¸ ê²½ìš°, sshpass ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì–´ì•¼ í•˜ë©°,
       ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ì´ë²ˆ ì ‘ì†ì€ ì·¨ì†Œí•˜ê³  sshpass ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.

ê²€ìƒ‰ì‹ (Search expression) ì˜ˆ:
  {dev} or {%prod%} and {web}
  - {í‚¤ì›Œë“œ} : group/name/host ì— í‚¤ì›Œë“œê°€ í¬í•¨ëœ í•­ëª©
  - %ë¬¸ìì—´% : ë¬¸ìì—´ì„ í¬í•¨í•˜ëŠ” í•­ëª©
  - ë¬¸ìì—´%  : í•´ë‹¹ ë¬¸ìì—´ë¡œ ì‹œì‘í•˜ëŠ” í•­ëª©
  - %ë¬¸ìì—´  : í•´ë‹¹ ë¬¸ìì—´ë¡œ ëë‚˜ëŠ” í•­ëª©
  - and / or : ì¡°ê±´ ê²°í•© (ì¤‘ì²© ì¤‘ê´„í˜¸ í˜•íƒœë„ ì§€ì›)

ì •ë ¬ ê·œì¹™ (Sort rule):
  1) group == "default" ì¸ í•­ëª©ì´ í•­ìƒ ìµœìƒìœ„
  2) ê·¸ ì™¸ group ì€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
  3) ê°™ì€ group ë‚´ì—ì„œëŠ” name ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

ì»¬ëŸ¼ ìˆœì„œ (Column order):
  #, Group, Name, Host, Port, User, Credential(í‘œì‹œ ì‹œ ë§ˆìŠ¤í‚¹ ë˜ëŠ” í‰ë¬¸)
EOF
}

# =======================================
# Common utils
# =======================================

##
# ë¡œê·¸ë¥¼ stderrë¡œ ì¶œë ¥í•œë‹¤. í¬ë§·ì€ [LEVEL] message í˜•íƒœì´ë‹¤.
# Print log messages to stderr in the form of [LEVEL] message.
#
# @param $1 {string} ë¡œê·¸ ë ˆë²¨ (ì˜ˆ: INFO, WARN, ERROR) / log level (e.g. INFO, WARN, ERROR)
# @param $2..$n {string} ì¶œë ¥í•  ë©”ì‹œì§€ ì¡°ê°ë“¤ / message tokens to be printed
#
# @return {int} í•­ìƒ 0 (í‘œì¤€ì—ëŸ¬ë¡œë§Œ ì¶œë ¥) / always 0 (only writes to stderr)
##
log() {
  local level="$1"
  shift
  printf '[%s] %s\n' "${level}" "$*" >&2
}

##
# ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ help()ë¥¼ í†µí•´ ì¶œë ¥í•˜ê³  ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¢…ë£Œí•œë‹¤.
# Print an error message via help() and terminate the script.
#
# @param $1..$n {string} ì—ëŸ¬ ë©”ì‹œì§€ ì „ì²´ (ê³µë°± í¬í•¨) / full error message (can include spaces)
#
# @return {int} exit 1ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¦‰ì‹œ ì¢…ë£Œ / terminates the process with exit code 1
##
die() {
  local msg="$*"
  local line="${BASH_LINENO[0]:-0}"
  help "$msg" "$line"
  exit 1
}

##
# ì„¤ì • ë””ë ‰í† ë¦¬ì™€ ì„¤ì • íŒŒì¼ì„ ë³´ì¥í•˜ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ JSON êµ¬ì¡°ë¡œ ìƒì„±í•œë‹¤.
# Ensure the configuration directory/file exist; create with default JSON if missing.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„±ê³µ ì‹œ 0, ë””ë ‰í† ë¦¬/íŒŒì¼ ìƒì„± ì‹¤íŒ¨ ì‹œ ë¹„-0 ê°€ëŠ¥
#         0 on success, non-zero on directory/file creation failure.
##
ensure_config_file() {
  # CONFIG_FILE ê¸°ì¤€ìœ¼ë¡œ CONFIG_DIR ì¬ê³„ì‚°
  CONFIG_DIR="$(dirname "${CONFIG_FILE}")"

  if [[ ! -d "${CONFIG_DIR}" ]]; then
    mkdir -p "${CONFIG_DIR}"
  fi

  # masterkey íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ md5 ê³„ì‚°
  local masterkey_md5=""
  if [[ -f "${MASTERKEY_FILE}" ]]; then
    masterkey_md5="$(md5sum "${MASTERKEY_FILE}" | awk '{print $1}')"
  fi

  if [[ ! -f "${CONFIG_FILE}" ]]; then
    # ìƒˆ configuration íŒŒì¼ ìƒì„± ì‹œ masterkey_md5 í¬í•¨
    cat > "${CONFIG_FILE}" <<EOF
{
  "version": "${CONFIG_VERSION}",
  "masterkey_md5": "${masterkey_md5}",
  "connections": []
}
EOF
    chmod 600 "${CONFIG_FILE}"
  else
    chmod 600 "${CONFIG_FILE}" || true
  fi
}

##
# jq, ssh ë“±ì˜ í•„ìˆ˜ ì˜ì¡´ì„±ì„ ì ê²€í•˜ê³ , ëˆ„ë½ëœ ê²½ìš° ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¢…ë£Œí•œë‹¤.
# Check for required dependencies (jq, ssh); abort script if any is missing.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ëª¨ë“  ì˜ì¡´ì„±ì´ ì¡´ì¬í•˜ë©´ 0, ëˆ„ë½ ì‹œ die()ë¥¼ í†µí•´ exit 1
#         0 if all dependencies exist; otherwise terminates via die() with exit 1.
##
ensure_dependencies() {
  local missing=()

  if ! command -v jq >/dev/null 2>&1; then
    missing+=("jq")
  fi
  if ! command -v ssh >/dev/null 2>&1; then
    missing+=("ssh")
  fi
  if ! command -v md5sum >/dev/null 2>&1; then
    missing+=("md5sum")
  fi

  if [[ "${#missing[@]}" -gt 0 ]]; then
    die "Required commands are missing: ${missing[*]}"
  fi
}

##
# configuration.masterkey_md5 ì™€ ì‹¤ì œ MASTERKEY_FILE md5 ë¥¼ ë¹„êµí•´ ì •í•©ì„±ì„ ê²€ì¦í•œë‹¤.
# MASTERKEY_FILE ì´ ì—†ìœ¼ë©´ OpenSSH private key ë¥¼ ìƒì„±í•˜ê³ , í•„ìš”í•œ ê²½ìš° ì‚¬ìš©ìì—ê²Œ
# ìƒˆë¡œìš´ masterkey ê²½ë¡œë¥¼ ì…ë ¥ë°›ì•„ configuration ê³¼ì˜ ì •í•©ì„±ì„ ë§ì¶˜ë‹¤.
# Verify consistency between configuration.masterkey_md5 and actual MASTERKEY_FILE md5.
# If MASTERKEY_FILE does not exist, create an OpenSSH private key, and if necessary,
# interactively ask the user for a new masterkey path until it matches configuration.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„±ê³µ ì‹œ 0, ì‚¬ìš©ì ì·¨ì†Œ ë˜ëŠ” ë³µêµ¬ ë¶ˆê°€ ì‹œ die() ë¥¼ í†µí•´ ì¢…ë£Œ
#         0 on success; terminates via die() when user cancels or mismatch cannot be resolved.
##
ensure_masterkey_md5() {
  # 1) MASTERKEY_FILE ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ OpenSSH private key ìƒì„±
  # 1) If MASTERKEY_FILE does not exist, create an OpenSSH private key.
  if [[ ! -f "${MASTERKEY_FILE}" ]]; then
    local key_dir
    key_dir="$(dirname "${MASTERKEY_FILE}")"

    if [[ ! -d "${key_dir}" ]]; then
      mkdir -p "${key_dir}"
    fi

    echo
    echo "â— masterkey(OpenSSH private key) íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "â— ìƒˆë¡œìš´ masterkey íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤."
    echo "â“ ssh-keygen ì‹¤í–‰ ì¤‘ì— í‘œì‹œë˜ëŠ” í”„ë¡¬í”„íŠ¸ì— ë”°ë¼ ë¹„ë°€ë²ˆí˜¸(passphrase)ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
    echo "ğŸ”‘ target: ${MASTERKEY_FILE}"
    echo

    # ì‚¬ìš©ìê°€ ì§ì ‘ passphrase ë¥¼ ì…ë ¥í•˜ë„ë¡ ssh-keygen ì„ ê·¸ëŒ€ë¡œ ì‹¤í–‰
    # Run ssh-keygen as-is so the user can provide a passphrase interactively.
    if ! ssh-keygen -t ed25519 -f "${MASTERKEY_FILE}"; then
      die "masterkey(OpenSSH private key) ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ssh-keygen ì‹¤íŒ¨)"
    fi

    if [[ ! -f "${MASTERKEY_FILE}" ]]; then
      die "masterkey(OpenSSH private key) íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: ${MASTERKEY_FILE}"
    fi
  fi

  # 2) configuration íŒŒì¼ì´ ì—†ìœ¼ë©´ ìƒì„±
  # 2) If configuration file does not exist, create it first.
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    ensure_config_file
  fi

  # 3) MASTERKEY_FILE md5 ê³„ì‚°
  # 3) Calculate md5 of MASTERKEY_FILE.
  local file_md5
  file_md5="$(md5sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # 4) configuration ì•ˆì˜ masterkey_md5 ì½ê¸° (ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´)
  # 4) Read masterkey_md5 from configuration (empty if missing).
  local config_md5
  config_md5="$(jq -r '.masterkey_md5 // ""' "${CONFIG_FILE}" 2>/dev/null || echo "")"

  # 5) configuration.masterkey_md5 ê°€ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆìœ¼ë©´ í˜„ì¬ md5 ë¡œ ì„¤ì •
  # 5) If configuration.masterkey_md5 is missing/empty, set it to current md5.
  if [[ -z "${config_md5}" || "${config_md5}" == "null" ]]; then
    local tmp
    tmp="$(mktemp "${CONFIG_FILE}.XXXXXX")"
    jq --arg md5 "${file_md5}" '.masterkey_md5 = $md5' "${CONFIG_FILE}" > "${tmp}"
    mv "${tmp}" "${CONFIG_FILE}"
    chmod 600 "${CONFIG_FILE}" || true
    return 0
  fi

  # 6) ê°’ì´ ë™ì¼í•˜ë©´ ì •ìƒ ì§„í–‰
  # 6) If md5 values are equal, everything is consistent.
  if [[ "${config_md5}" == "${file_md5}" ]]; then
    return 0
  fi

  # 7) ê°’ì´ ë‹¤ë¥´ë©´ ì‚¬ìš©ìì—ê²Œ ìƒˆë¡œìš´ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥ë°›ì•„ ì¬ê²€ì¦
  # 7) If md5 values differ, ask the user for a new masterkey path and re-validate.
  local current_path="${MASTERKEY_FILE}"
  local current_md5="${file_md5}"

  while true; do
    local line
    line="============================================================================"

    echo "${line}"
    printf 'âš™ï¸  masterkey_file              : %s\n' "${current_path}"
    printf 'âš™ï¸  masterkey_file.md5          : %s\n' "${current_md5}"
    printf 'âš™ï¸  configuration.masterkey_md5 : %s\n' "${config_md5}"
    echo "${line}"
    echo
    echo "â— MASTERKEY_FILE ê³¼ configuration.masterkey_md5 ê°’ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "â— configuration ì— ì €ì¥ëœ masterkey_md5 ì™€ ë™ì¼í•œ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
    echo 
    echo "   (ì…ë ¥ì„ ë¹„ìš°ê³  Enter ë¥¼ ëˆ„ë¥´ë©´ ì‘ì—…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.)"
    echo

    printf "ìƒˆ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš”: "
    local new_path
    IFS= read -r new_path || {
      die "masterkey ê²€ì¦ ì¤‘ ì…ë ¥ì„ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    }

    # ì‚¬ìš©ìê°€ ë¹ˆ ë¬¸ìì—´ì„ ì…ë ¥í•˜ë©´ ì·¨ì†Œë¡œ ê°„ì£¼
    # Treat empty input as user cancellation.
    if [[ -z "${new_path}" ]]; then
      die "masterkey ê²€ì¦ì´ ì‚¬ìš©ìì— ì˜í•´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
    fi

    # ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€ ê²€ì¦
    # Verify that the given path exists.
    local abs_new_path=$(resolve_path_abs "${new_path}")
    if [[ ! -f "${abs_new_path}" ]]; then
      echo "â— ì§€ì •í•œ masterkey íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${abs_new_path}" >&2
      echo 
      echo "   ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
      echo
      continue
    fi

    # ìƒˆ íŒŒì¼ì˜ md5 ê³„ì‚°
    local new_md5
    new_md5="$(md5sum "${abs_new_path}" | awk '{print $1}')"

    if [[ "${new_md5}" == "${config_md5}" ]]; then
      # ì¼ì¹˜í•˜ë©´ MASTERKEY_FILE ì„ ìƒˆ ê²½ë¡œë¡œ ê°±ì‹ í•˜ê³  ì •ìƒ ì¢…ë£Œ
      # On match, update MASTERKEY_FILE and return success.
      MASTERKEY_FILE="${abs_new_path}"
      return 0
    fi

    # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ í˜„ì¬ ê°’ ê°±ì‹  í›„ ë£¨í”„ ë°˜ë³µ
    # If mismatched, update current values and loop.
    current_path="${abs_new_path}"
    current_md5="${new_md5}"
  done
}

##
# ì…ë ¥ëœ í‰ë¬¸(ë¯¼ê°ì •ë³´: username, credential)ì„ AES-256-CBC ë°©ì‹ìœ¼ë¡œ ì•”í˜¸í™”í•œë‹¤.
# Encrypt plaintext (username, credential) using AES-256-CBC with key derived from MASTERKEY_FILE.
#
# @param $1 {string} plaintext í‰ë¬¸ ë°ì´í„°
#
# @return {string} ENC::<base64_cipher>
##
encrypt_value() {
  local plaintext="$1"

  # ë¹ˆ ë¬¸ìì—´ì€ ì•”í˜¸í™”í•  í•„ìš” ì—†ìŒ
  if [[ -z "$plaintext" ]]; then
    echo ""
    return 0
  fi

  # íŒŒìƒí‚¤ ìƒì„±: SHA-256(masterkey íŒŒì¼ ë‚´ìš©)
  local derived_key
  derived_key="$(sha256sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # AES-256-CBC ì•”í˜¸í™” (base64 ì¶œë ¥)
  local cipher
  # Base64 ë‹¨ì¼ ë¼ì¸ ê°•ì œ
  cipher="$(echo -n "$plaintext" \
      | openssl enc -aes-256-cbc -a -A -salt -pass pass:"$derived_key" 2>/dev/null)"

  if [[ $? -ne 0 || -z "$cipher" ]]; then
    die "ë¯¼ê°ì •ë³´ ì•”í˜¸í™”(encrypt_value) ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
  fi

  echo "ENC::${cipher}"
}

##
# ì…ë ¥ëœ ê°’ì´ ENC:: ë¡œ ì‹œì‘í•˜ë©´ ë³µí˜¸í™”í•˜ì—¬ í‰ë¬¸ì„ ë°˜í™˜í•œë‹¤.
# If value starts with ENC::, decrypt it using AES-256-CBC with derived key.
#
# @param $1 {string} value ì•”í˜¸ë¬¸ ë˜ëŠ” í‰ë¬¸
#
# @return {string} í‰ë¬¸ ë°ì´í„°
##
decrypt_value_if_needed() {
  local value="$1"

  # ì•”í˜¸ë¬¸ì´ ì•„ë‹ˆë¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if [[ "$value" != ENC::* ]]; then
    echo "$value"
    return 0
  fi

  # cipher ë¶€ë¶„ë§Œ ì¶”ì¶œ
  local cipher="${value#ENC::}"

  # íŒŒìƒí‚¤ ìƒì„±
  local derived_key
  derived_key="$(sha256sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # ë³µí˜¸í™”
  local plaintext
  plaintext="$(echo "$cipher" \
      | openssl enc -aes-256-cbc -a -d -salt -pass pass:"$derived_key" 2>/dev/null)"

  if [[ $? -ne 0 ]]; then
    die "ë¯¼ê°ì •ë³´ ë³µí˜¸í™”(decrypt_value_if_needed) ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
  fi

  echo "$plaintext"
}

##
# STDINìœ¼ë¡œ ì „ë‹¬ëœ JSONì„ ì„ì‹œ íŒŒì¼ì„ ì‚¬ìš©í•´ CONFIG_FILEì— ì•ˆì „í•˜ê²Œ ì €ì¥í•œë‹¤.
# Safely save JSON from STDIN into CONFIG_FILE using a temporary file.
#
# @param $1 ì—†ìŒ (ì…ë ¥ì€ STDINìœ¼ë¡œ ì „ë‹¬) / none (input JSON is read from STDIN)
#
# @return {int} ì„±ê³µ ì‹œ 0, íŒŒì¼ ì“°ê¸°/ì´ë™ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on write/move failures.
##
save_connections_json() {
  local tmp
  tmp="$(mktemp "${CONFIG_FILE}.XXXXXX")"
  cat > "${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}"
}

##
# ~, ìƒëŒ€ê²½ë¡œ ë“±ì„ í¬í•¨í•œ ê²½ë¡œë¥¼ ì ˆëŒ€ê²½ë¡œë¡œ ì •ê·œí™”í•œë‹¤.
# Normalize a given path (including ~ and relative paths) into an absolute path.
#
# @param $1 {string} ì›ë³¸ ê²½ë¡œ (ìƒëŒ€/ì ˆëŒ€/tilde í¬í•¨ ê°€ëŠ¥) / original path (relative/absolute/tilde)
#
# @return {string} STDOUTë¡œ ì ˆëŒ€ê²½ë¡œë¥¼ ì¶œë ¥ / prints the absolute path to STDOUT
# @return {int} í•­ìƒ 0 (readlink ì˜¤ë¥˜ ì‹œ ì›ë˜ ê²½ë¡œ ê¸°ì¤€) / always 0; falls back when readlink fails.
##
resolve_path_abs() {
  local p="$1"

  if [[ -z "$p" ]]; then
    printf '%s\n' ""
    return 0
  fi

  if [[ "$p" == ~* ]]; then
    p="${p/#\~/$HOME}"
  fi

  if [[ "$p" != /* ]]; then
    p="${PWD}/${p}"
  fi

  if command -v readlink >/dev/null 2>&1; then
    local r
    if r=$(readlink -f -- "$p" 2>/dev/null); then
      p="$r"
    fi
  fi

  printf '%s\n' "$p"
}

##
# SHOW_CREDENTIAL í”Œë˜ê·¸ì— ë”°ë¼ credential ì¶œë ¥ê°’ì„ ê²°ì •í•œë‹¤.
# Decide how to display credential value depending on SHOW_CREDENTIAL flag.
#
# @param $1 {string} cred ì‹¤ì œ credential ê°’ / actual credential value
#
# @return {string} STDOUTë¡œ í‘œì‹œìš© credential ì¶œë ¥ / prints displayable credential to STDOUT.
# @return {int} í•­ìƒ 0 / always 0.
##
format_credential_for_display() {
  local cred="$1"

  case "$EXEC_CMD" in
    # [ì—°ê²°ì •ë³´ ëª©ë¡] (-l | --list-all)
    # - ê¸°ë³¸: masking list (****************)
    # - -s / --show-credential ì´ ìˆëŠ” ê²½ìš°: plain list
    list)
      if [[ "$SHOW_CREDENTIAL" == "true" ]]; then
        printf '%s' "$cred"
      else
        printf '****************'
      fi
      ;;

    # [ì—°ê²°ì •ë³´ ì¶”ê°€] (-a | --add-connection)
    # - ê¸°ë³¸: masking list
    # - -s / --show-credential ì´ ìˆëŠ” ê²½ìš°: ë¯¸ë¦¬ë³´ê¸°ì—ì„œë§Œ plain
    add)
      if [[ "$SHOW_CREDENTIAL" == "true" ]]; then
        printf '%s' "$cred"
      else
        printf '****************'
      fi
      ;;

    # [ì—°ê²°ì •ë³´ ìˆ˜ì •] (-m | --modify-connection)
    # - ìš”êµ¬ì‚¬í•­: "plain list" ë¥¼ ëŒ€ìƒìœ¼ë¡œ ë™ì‘
    # - --show-credential ì˜µì…˜ ì§€ì›í•˜ì§€ ì•ŠìŒ (ìˆì–´ë„ ë¬´ì‹œ) â†’ í•­ìƒ í‰ë¬¸ í‘œì‹œ
    modify)
      printf '%s' "$cred"
      ;;

    # [ì„œë²„ ì ‘ì†], [ì—°ê²°ì •ë³´ ì‚­ì œ], [ì—°ê²°ì •ë³´ ê·¸ë£¹ì´ë™]
    # - ìš”êµ¬ì‚¬í•­: í•­ìƒ "masking list"
    # - --show-credential ì˜µì…˜ ì§€ì›í•˜ì§€ ì•ŠìŒ â†’ í•­ìƒ ë§ˆìŠ¤í‚¹
    connect|delete|move-group)
      printf '****************'
      ;;

    # ê·¸ ì™¸ (ì•ˆì „í•˜ê²Œ ê¸°ë³¸ì€ ë§ˆìŠ¤í‚¹)
    *)
      printf '****************'
      ;;
  esac
}

##
# sshpass ê°€ ì—†ì„ ê²½ìš° ì‹œìŠ¤í…œ íŒ¨í‚¤ì§€ ê´€ë¦¬ì(apt, yum/dnf, zypper, apk ë“±)ë¥¼ ì‚¬ìš©í•´ ì„¤ì¹˜ë¥¼ ì‹œë„í•œë‹¤.
# Try to install sshpass using system package manager (apt, yum/dnf, zypper, apk, etc.) if not present.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„¤ì¹˜ í›„ sshpass ê°€ ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ 0, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 1
#         0 if sshpass becomes available after installation; 1 otherwise.
##
install_sshpass_if_missing() {
  if command -v sshpass >/dev/null 2>&1; then
    return 0
  fi

  log INFO "sshpass not found. Trying to install..."

  local pm=""
  if command -v apt-get >/dev/null 2>&1; then
    pm="apt"
  elif command -v dnf >/dev/null 2>&1; then
    pm="dnf"
  elif command -v yum >/dev/null 2>&1; then
    pm="yum"
  elif command -v zypper >/dev/null 2>&1; then
    pm="zypper"
  elif command -v apk >/dev/null 2>&1; then
    pm="apk"
  fi

  case "$pm" in
    apt)
      if sudo apt-get update && sudo apt-get install -y sshpass; then
        log INFO "sshpass installed via apt."
      fi
      ;;
    dnf)
      if sudo dnf install -y sshpass; then
        log INFO "sshpass installed via dnf."
      fi
      ;;
    yum)
      if sudo yum install -y sshpass; then
        log INFO "sshpass installed via yum."
      fi
      ;;
    zypper)
      if sudo zypper install -y sshpass; then
        log INFO "sshpass installed via zypper."
      fi
      ;;
    apk)
      if sudo apk add sshpass; then
        log INFO "sshpass installed via apk."
      fi
      ;;
    *)
      log WARN "Unsupported package manager. Please install sshpass manually."
      ;;
  esac

  if command -v sshpass >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

# =======================================
# Validation helpers
# =======================================

##
# ê°’ì´ ë¹„ì–´ ìˆì§€ ì•Šì€ì§€ ê²€ì‚¬í•œë‹¤. ë¹„ì–´ ìˆìœ¼ë©´ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.
# Validate that a given value is not empty; prints an error message if it is empty.
#
# @param $1 {string} í•„ë“œ ë ˆì´ë¸” (ì˜ˆ: group, name) / field label (e.g. group, name)
# @param $2 {string} ì‹¤ì œ ê°’ / actual value
#
# @return {int} ë¹„ì–´ ìˆì§€ ì•Šìœ¼ë©´ 0, ë¹„ì–´ ìˆìœ¼ë©´ 1
#         0 if non-empty; 1 if empty.
##
validate_non_empty() {
  local label="$1"
  local value="$2"
  if [[ -z "$value" ]]; then
    printf 'ì…ë ¥ ì˜¤ë¥˜: %s ì€(ëŠ”) ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n' "$label" >&2
    return 1
  fi
  return 0
}

##
# host_type ê°’ì´ ipv4|ipv6|domain ì¤‘ í•˜ë‚˜ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that host_type is one of ipv4, ipv6, or domain.
#
# @param $1 {string} host_type ê°’ / host_type value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_host_type() {
  local value="$1"
  case "$value" in
    ipv4|ipv6|domain)
      return 0
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: host_type ì€ ipv4|ipv6|domain ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
      return 1
      ;;
  esac
}

##
# auth_type ê°’ì´ password|key ì¤‘ í•˜ë‚˜ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that auth_type is either password or key.
#
# @param $1 {string} auth_type ê°’ / auth_type value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_auth_type() {
  local value="$1"
  case "$value" in
    password|key)
      return 0
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: auth_type ì€ password|key ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
      return 1
      ;;
  esac
}

##
# port ê°’ì´ ìˆ«ìì´ê³  1~65535 ë²”ìœ„ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that port is numeric and in the range 1â€“65535.
#
# @param $1 {string} í¬íŠ¸ ë¬¸ìì—´ / port string
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_port() {
  local value="$1"
  if ! [[ "$value" =~ ^[0-9]+$ ]]; then
    printf 'ì…ë ¥ ì˜¤ë¥˜: port ëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
    return 1
  fi
  if (( value < 1 || value > 65535 )); then
    printf 'ì…ë ¥ ì˜¤ë¥˜: port ë²”ìœ„ëŠ” 1 ~ 65535 ì…ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
    return 1
  fi
  return 0
}

##
# host_type ìœ í˜•ì— ë”°ë¼ host í˜•ì‹ì„ ê²€ì¦í•œë‹¤.
# Validate host format based on host_type (ipv4, ipv6, or domain).
#
# @param $1 {string} host_type (ipv4|ipv6|domain)
# @param $2 {string} host ê°’ / host value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê²½ìš° 1
#         0 if valid; 1 if invalid.
##
validate_host_by_type() {
  local host_type="$1"
  local host="$2"

  case "$host_type" in
    ipv4)
      if ! [[ "$host" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: ipv4 host í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì˜ˆ: 192.168.0.10)\n' >&2
        return 1
      fi
      ;;
    ipv6)
      if [[ "$host" != *:* ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: ipv6 host ëŠ” ":" ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.\n' >&2
        return 1
      fi
      ;;
    domain)
      if ! [[ "$host" =~ ^[A-Za-z0-9.-]+$ ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: domain host í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì˜ˆ: gitlab.ymtech.co.kr)\n' >&2
        return 1
      fi
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: ì•Œ ìˆ˜ ì—†ëŠ” host_type ì…ë‹ˆë‹¤: %s\n' "$host_type" >&2
      return 1
      ;;
  esac
  return 0
}

# =======================================
# Prompt label width ì´ˆê¸°í™”
# =======================================

##
# í”„ë¡¬í”„íŠ¸ì—ì„œ ì‚¬ìš©í•  í•„ë“œëª… ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ PROMPT_LABEL_WIDTHë¥¼ ê³„ì‚°í•œë‹¤.
# Compute PROMPT_LABEL_WIDTH based on the maximum length of field labels.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} í•­ìƒ 0, PROMPT_LABEL_WIDTH ì „ì—­ ë³€ìˆ˜ ì„¤ì •
#         Always 0; sets global PROMPT_LABEL_WIDTH.
##
init_prompt_label_width() {
  local labels=(
    "group"
    "name"
    "host_type (ipv4|ipv6|domain)"
    "host"
    "port"
    "username"
    "auth_type (password|key)"
    "password"
    "key path"
    "ìƒˆ group"
  )
  local max=0 len
  for f in "${labels[@]}"; do
    len=${#f}
    if (( len > max )); then
      max=$len
    fi
  done
  # ì•„ì´ì½˜(2ì¹¸ ê°€ì •) + ê³µë°± 2ì¹¸ + í•„ë“œëª… + ì—¬ìœ  2ì¹¸
  PROMPT_LABEL_WIDTH=$((max + 6))
}

# =======================================
# Search expression â†’ jq filter
# =======================================

##
# ë‹¨ì¼ í‚¤ì›Œë“œ(ì™€ì¼ë“œì¹´ë“œ % í¬í•¨)ë¥¼ ì´ìš©í•´ group/name/hostì— ëŒ€í•œ jq ì¡°ê±´ì‹ì„ ìƒì„±í•œë‹¤.
# Build a jq condition for a single keyword (with % wildcards) over group/name/host.
#
# @param $1 {string} ê²€ìƒ‰ í‚¤ì›Œë“œ (ì˜ˆ: git, g%, %lab, %prod%) / search keyword with optional % wildcards
#
# @return {string} STDOUTë¡œ jq boolean í‘œí˜„ì‹ ì¶œë ¥ / prints jq boolean expression to STDOUT
# @return {int} 0 (ì •ìƒ) / 0 on success.
##
build_single_condition() {
  local kw="$1"
  local mode="contains"
  local core="$kw"

  if [[ "$core" == %*% ]]; then
    core="${core#%}"
    core="${core%%%}"
    mode="contains"
  elif [[ "$core" == *% ]]; then
    core="${core%%%}"
    mode="starts"
  elif [[ "$core" == %* ]]; then
    core="${core#%}"
    mode="ends"
  else
    mode="contains"
  fi

  local core_l="${core,,}"

  local esc
  esc="$(printf '%s' "$core_l" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"

  local field_expr_group='.group // "" | ascii_downcase'
  local field_expr_name='.name // "" | ascii_downcase'
  local field_expr_host='.host // "" | ascii_downcase'

  local cmp_func=""
  case "$mode" in
    contains)
      cmp_func="contains(\"$esc\")"
      ;;
    starts)
      cmp_func="startswith(\"$esc\")"
      ;;
    ends)
      cmp_func="endswith(\"$esc\")"
      ;;
    *)
      cmp_func="contains(\"$esc\")"
      ;;
  esac

  printf '((%s | %s) or (%s | %s) or (%s | %s))' \
    "$field_expr_group" "$cmp_func" \
    "$field_expr_name"  "$cmp_func" \
    "$field_expr_host"  "$cmp_func"
}

##
# ì „ì²´ ê²€ìƒ‰ì‹(expr)ì„ íŒŒì‹±í•˜ì—¬ AND/OR ì¡°í•© jq filter í‘œí˜„ì‹ìœ¼ë¡œ ë³€í™˜í•œë‹¤.
# Parse a whole search expression and convert it into a jq filter with AND/OR conditions.
#
# @param $1 {string} ê²€ìƒ‰ì‹ ë¬¸ìì—´ (ì˜ˆ: {dev} or {%prod%} and {web}) / raw search expression string
#
# @return {string} STDOUTë¡œ ì™„ì„±ëœ jq filter ë¬¸ìì—´ ì¶œë ¥ / prints final jq filter string to STDOUT
# @return {int} 0 (ì •ìƒ), ê²€ìƒ‰ì‹ì´ ë¹„ì–´ ìˆìœ¼ë©´ "true" ì¶œë ¥
#         0 on success; prints "true" for empty expressions.
##
build_search_filter() {
  local expr="$1"

  # ì–‘ìª½ ê³µë°± ì œê±°
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  # ë¹ˆ expr ì´ë©´ ì „ì²´(true)
  if [[ -z "$expr" ]]; then
    echo "true"
    return 0
  fi

  _build_search_filter_inner "$expr"
}

# ë‚´ë¶€ ì¬ê·€ íŒŒì„œ
_build_search_filter_inner() {
  local expr="$1"

  # ì†Œë¬¸ì + ê³µë°± ì •ê·œí™”
  expr="${expr,,}"
  expr="$(printf '%s' "$expr" | tr -s '[:space:]' ' ')"
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  local conds=()
  local ops=()
  local rest="$expr"

  while [[ -n "$rest" ]]; do
    # ì•ìª½ ê³µë°± ì œê±°
    rest="${rest#"${rest%%[![:space:]]*}"}"
    [[ -z "$rest" ]] && break

    if [[ "${rest:0:1}" == "{" ]]; then
      # ì¤‘ì²© { } ì²˜ë¦¬ìš© brace depth
      local depth=0
      local len=${#rest}
      local i
      for ((i=0; i<len; i++)); do
        local ch="${rest:i:1}"
        if [[ "$ch" == "{" ]]; then
          depth=$((depth+1))
        elif [[ "$ch" == "}" ]]; then
          depth=$((depth-1))
          if (( depth == 0 )); then
            break
          fi
        fi
      done

      # ì¤‘ê´„í˜¸ ë¶ˆì¼ì¹˜ â†’ ì „ì²´ë¥¼ ë‹¨ì¼ í‚¤ì›Œë“œë¡œ ì²˜ë¦¬
      if (( depth != 0 )); then
        conds=( "$(build_single_condition "$expr")" )
        break
      fi

      local close_pos="$i"
      local inner_len=$((close_pos - 1))
      local inside="${rest:1:inner_len}"   # ê°€ì¥ ë°”ê¹¥ { } ì•ˆìª½
      local next_pos=$((close_pos + 1))
      local remaining="${rest:next_pos}"

      if [[ "$inside" == *"{"* ]]; then
        # ë‚´ë¶€ì— ë˜ { ê°€ ìˆìœ¼ë©´, ë‹¤ì‹œ Expr ë¡œ ì¬ê·€ íŒŒì‹±
        local sub_filter
        sub_filter="$(_build_search_filter_inner "$inside")" || return 1
        conds+=( "(${sub_filter})" )
      else
        # ë‹¨ìˆœ í‚¤ì›Œë“œ
        conds+=( "$(build_single_condition "$inside")" )
      fi

      rest="$remaining"
    else
      # ì•ˆì „ì¥ì¹˜: { ë¡œ ì‹œì‘í•˜ì§€ ì•ŠëŠ” í† í°ì€ "ë‹¨ì¼ í‚¤ì›Œë“œ" ì·¨ê¸‰
      local token="${rest%% *}"
      local remaining="${rest#* }"
      if [[ "$token" == "$rest" ]]; then
        remaining=""
      fi
      conds+=( "$(build_single_condition "$token")" )
      rest="$remaining"
    fi

    # op (and|or) íŒŒì‹±
    rest="${rest#"${rest%%[![:space:]]*}"}"
    if [[ "$rest" =~ ^(and|or)[[:space:]]+(.*)$ ]]; then
      ops+=( "${BASH_REMATCH[1]}" )
      rest="${BASH_REMATCH[2]}"
    else
      break
    fi
  done

  # term ì´ í•˜ë‚˜ë„ ì•ˆ ì¡í˜”ìœ¼ë©´ ì „ì²´ expr ì„ ë‹¨ì¼ í‚¤ì›Œë“œë¡œ ì²˜ë¦¬
  if (( ${#conds[@]} == 0 )); then
    printf '%s\n' "$(build_single_condition "$expr")"
    return 0
  fi

  # ì™¼ìª½ë¶€í„° fold: ((t1 op1 t2) op2 t3) ...
  local result="${conds[0]}"
  local i
  for ((i=0; i<${#ops[@]}; i++)); do
    local op="${ops[$i]}"
    local rhs="${conds[$((i+1))]}"
    result="(${result} ${op} ${rhs})"
  done

  printf '%s\n' "$result"
}

# =======================================
# List / selection helpers
# =======================================

##
# ê²€ìƒ‰ì‹ì„ ì´ìš©í•´ connectionsë¥¼ í•„í„°ë§í•˜ê³  íƒ­ êµ¬ë¶„ ì›ì‹œ ë¬¸ìì—´ë¡œ ë°˜í™˜í•œë‹¤.
# Filter connections using a search expression and return tab-separated raw lines.
#
# @param $1 {string} query ê²€ìƒ‰ì‹ (ë¹ˆ ë¬¸ìì—´ì´ë©´ ì „ì²´) / search query; empty for all connections
#
# @return {string} STDOUTë¡œ "group\tname\thost\tport\tusername\tcredential" ë¼ì¸ë“¤ì„ ì¶œë ¥
#         prints lines of "group\tname\thost\tport\tusername\tcredential" to STDOUT.
# @return {int} jq ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë¹„-0, ì •ìƒ ì‹œ 0
#         0 on success; non-zero if jq fails.
##
_get_filtered_raw_connections() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  jq -r '
    .connections
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)"
  ' "$CONFIG_FILE"
}

##
# í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ì„¤ì • íŒŒì¼ / masterkey ê²½ë¡œë¥¼ ë°°ë„ˆ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Print configuration / masterkey paths as a banner before connection tables.
#
# @param $1 {none} ì—†ìŒ / none
#
# @return {int} í•­ìƒ 0 / always 0.
##
print_config_summary_banner() {
  local line
  line="============================================================================"
  printf '%s\n' "$line"
  printf 'âš™ï¸ configuration: %s\n' "${CONFIG_FILE}"
  printf 'âš™ï¸ masterkey    : %s\n' "${MASTERKEY_FILE:-<not set>}"
  printf '%s\n' "$line"
}

##
# íƒ­ êµ¬ë¶„ ì›ì‹œ ë¬¸ìì—´ì„ ì¸ë±ìŠ¤ ì»¬ëŸ¼(#)ì´ í¬í•¨ëœ í‘œ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Render a tab-separated raw string as a table with index (#) column.
#
# @param $1 {string} raw "group\tname\thost\tport\tuser\tcredential" í˜•ì‹ì˜ ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´
#                      multi-line string in "group\tname\thost\tport\tuser\tcredential" format
#
# @return {int} ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 1, í‘œ ì¶œë ¥ ì‹œ 0
#         1 when no data; 0 when table is printed successfully.
##
print_raw_as_table() {
  local raw="$1"

  if [[ -z "$raw" ]]; then
    echo "ì €ì¥ëœ ì—°ê²°ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  # ì„¤ì •ì •ë³´ ë°°ë„ˆ ì¶œë ¥
  print_config_summary_banner

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    local n=0 group name host port user cred display_cred

    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      local idx
      printf -v idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      temp_buffer+="${idx}\t${group}\t${name}\t${host}\t${port}\t${user}\t${display_cred}\n"
    done <<< "$raw"

    # column ê²°ê³¼ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í—¤ë” ê¸¸ì´ë¥¼ êµ¬í•´ì„œ
    # '-' êµ¬ë¶„ì„ ê³¼ '=' êµ¬ë¶„ì„ ì„ í•¨ê»˜ ë§Œë“ ë‹¤.
    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}

    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    # ìœ„/ì•„ë˜ '=' ë¼ì¸ ì¶”ê°€
    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential"
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------"

    local n=0 group name host port user cred display_cred idx
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      printf -v idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" "$idx" "$group" "$name" "$host" "$port" "$user" "$display_cred"
    done <<< "$raw"
  fi

  return 0
}

##
# ì¸ë±ìŠ¤ ì—†ì´ ê¸°ë³¸ ì»¬ëŸ¼ë§Œ í¬í•¨í•˜ëŠ” í‘œë¥¼ ì¶œë ¥í•œë‹¤.
# Render a table without index column using only base fields.
#
# @param $1 {string} raw "group\tname\thost\tport\tuser\tcredential" í˜•ì‹ì˜ ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´
#
# @return {int} ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 1, í‘œ ì¶œë ¥ ì‹œ 0
#         1 when no data; 0 when table is printed successfully.
##
print_raw_as_table_no_index() {
  local raw="$1"

  if [[ -z "$raw" ]]; then
    echo "ì €ì¥ëœ ì—°ê²°ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  # ì„¤ì •ì •ë³´ ë°°ë„ˆ ì¶œë ¥
  print_config_summary_banner

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    local group name host port user cred display_cred

    temp_buffer+="Group\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      temp_buffer+="${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    # column ê²°ê³¼ë¥¼ í•œ ë²ˆ ë§Œë“¤ì–´ì„œ, í—¤ë” ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ
    # '-' êµ¬ë¶„ì„ ê³¼ '=' êµ¬ë¶„ì„ ì„ ëª¨ë‘ ìƒì„±
    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}

    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    # ìœ„/ì•„ë˜ '=' ë¼ì¸ ì¶”ê°€
    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"  
  else
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "Group" "Name" "Host" "Port" "User" "Credential"
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "-----" "----" "----" "----" "----" "----------"

    local group name host port user cred display_cred
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$group" "$name" "$host" "$port" "$user" "$display_cred"
    done <<< "$raw"
  fi

  return 0
}

##
# queryë¥¼ ì´ìš©í•´ connection ëª©ë¡ì„ í•„í„°ë§í•˜ê³  í‘œ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Filter connections by query and print them as a table.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search query; empty for all
#
# @return {int} ë‚´ë¶€ print_raw_as_table ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table.
##
print_connections_table() {
  local query="${1:-}"
  local raw
  raw="$(_get_filtered_raw_connections "$query")"
  print_raw_as_table_no_index "$raw"
}

##
# ë‹¨ì¼ connection í•„ë“œë“¤ì„ ë°›ì•„ ì¸ë±ìŠ¤ ì—†ëŠ” 1í–‰ í‘œë¡œ ì¶œë ¥í•œë‹¤.
# Print a single connection as a one-row table without index column.
#
# @param $1 {string} group
# @param $2 {string} name
# @param $3 {string} host
# @param $4 {string} port
# @param $5 {string} username
# @param $6 {string} credential (password ë˜ëŠ” key path)
#
# @return {int} ë‚´ë¶€ print_raw_as_table_no_index ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table_no_index.
##
print_single_connection_from_fields() {
  local group="$1"
  local name="$2"
  local host="$3"
  local port="$4"
  local username="$5"
  local credential="$6"

  local raw="${group}\t${name}\t${host}\t${port}\t${username}\t${credential}"
  print_raw_as_table_no_index "$raw"
}

##
# ë‹¨ì¼ connection JSON ê°ì²´ë¥¼ ë°›ì•„ ìš”ì•½ ì •ë³´ë¥¼ í‘œë¡œ ì¶œë ¥í•œë‹¤.
# Print a preview table for a single connection JSON object.
#
# @param $1 {string(json)} connection JSON ê°ì²´ ë¬¸ìì—´ / JSON string for a single connection
#
# @return {int} ë‚´ë¶€ print_raw_as_table_no_index ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table_no_index.
##
print_connection_preview_from_json() {
  local json="$1"

  local raw
  raw="$(jq -r '
    { group, name, host, port, username, credential }
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)"
  ' <<< "$json")"

  print_raw_as_table_no_index "$raw"
}

##
# ê²€ìƒ‰ì‹ìœ¼ë¡œ connection í›„ë³´ë¥¼ í•„í„°ë§í•˜ê³ , ì‚¬ìš©ìê°€ ì„ íƒí•œ í•­ëª©ì˜ JSONì„ ë°˜í™˜í•œë‹¤.
# Filter connection candidates by query and return the selected one as JSON.
#
# @param $1 {string} query ê²€ìƒ‰ì‹ (ë¹ˆ ë¬¸ìì—´ì´ë©´ ì „ì²´) / search query; empty for all
#
# @return {string} STDOUTë¡œ { __idx, group, name, host, port, username, auth_type, credential } JSON ì¶œë ¥
#         prints selected connection JSON (including __idx) to STDOUT.
# @return {int} ì„ íƒ ì·¨ì†Œ ì‹œ 1, ì„±ê³µ ì‹œ 0
#         1 on cancel; 0 on success.
##
select_connection_interactively() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0
  local group name host port user cred idx display_cred

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # ë³´ì—¬ì¤„ ë°ì´í„°ëŠ” decript
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$separator"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # ë³´ì—¬ì¤„ ë°ì´í„°ëŠ” decript
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred" >&2
    done <<< "$raw"
  fi

  local sel
  local prompt_msg="â“  ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” (ì˜ˆ: 1, 2, 3): "
  while true; do
    read -r -p "$prompt_msg" sel
    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi
    if ! [[ "$sel" =~ ^[0-9]+$ ]] || (( sel < 1 || sel > n )); then
      prompt_msg="â—  ì…ë ¥í•œ ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” (ì˜ˆ: 1, 2, 3): "
      continue
    fi
    break
  done

  local selected_idx="${idx_map[$sel]}"

  jq -c --argjson i "$selected_idx" '
    .connections
    | to_entries
    | .[$i]
    | { __idx: .key } + .value
  ' "$CONFIG_FILE"
}

##
# ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ í”„ë¡¬í”„íŠ¸ë¥¼ í†µí•´ ì…ë ¥ì„ ë°›ê³ , ë¹„ì–´ ìˆìœ¼ë©´ ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•˜ëŠ” í—¬í¼ì´ë‹¤.
# Prompt user for a value, falling back to the current/default value if input is empty.
#
# @param $1 {string} label í‘œì‹œí•  ë¼ë²¨ / label text for the prompt
# @param $2 {string|empty} current ê¸°ë³¸ê°’ / current/default value
#
# @return {string} STDOUTë¡œ ìµœì¢… ì…ë ¥ê°’ ì¶œë ¥ / prints final input value to STDOUT.
# @return {int} í•­ìƒ 0 / always 0.
##
prompt_with_default() {
  local label="$1"
  local current="${2:-}"
  local var
  if [[ -n "${current}" ]]; then
    read -r -p "â“  ${label} [${current}]: " var
    if [[ -z "${var}" ]]; then
      var="${current}"
    fi
  else
    read -r -p "â“  ${label}: " var
  fi
  printf '%s' "${var}"
}

##
# ì•„ì´ì½˜ê³¼ í•„ë“œëª…ì„ PROMPT_LABEL_WIDTH ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì…ë ¥ì„ ë°›ëŠ”ë‹¤.
# Prompt with an icon and field name aligned by PROMPT_LABEL_WIDTH.
#
# @param $1 {string} icon í”„ë¡¬í”„íŠ¸ì— ì‚¬ìš©í•  ì•„ì´ì½˜ / icon to display
# @param $2 {string} field í•„ë“œ ì´ë¦„ / field name
# @param $3 {string|empty} current í˜„ì¬/ê¸°ë³¸ ê°’ / current/default value
#
# @return {string} STDOUTë¡œ ìµœì¢… ì…ë ¥ê°’ ì¶œë ¥ / prints final input value to STDOUT.
# @return {int} í•­ìƒ 0 / always 0.
##
prompt_with_icon() {
  local icon="$1"
  local field="$2"
  local current="${3:-}"
  local raw label input

  raw="${icon}  ${field}"
  printf -v label "%-*s" "$PROMPT_LABEL_WIDTH" "$raw"

  if [[ -n "$current" ]]; then
    read -r -p "â“  ${label} [${current}]: " input
    if [[ -z "$input" ]]; then
      input="$current"
    fi
  else
    read -r -p "â“  ${label}: " input
  fi

  printf '%s' "$input"
}

# =======================================
# JSON update helpers
# =======================================

##
# ì„ íƒëœ connectionì˜ ì¸ë±ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œìš´ ê°’ë“¤ë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Update a connection (by its index) with new values and output the full updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
# @param $2 {string} new_group
# @param $3 {string} new_name
# @param $4 {string} new_host_type
# @param $5 {string} new_host
# @param $6 {string} new_port (ë¬¸ìì—´, jqì—ì„œ ìˆ«ìë¡œ ë³€í™˜) / port as string (converted to number in jq)
# @param $7 {string} new_username
# @param $8 {string} new_auth_type
# @param $9 {string} new_credential
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_modify() {
  local selected_json="$1"
  local new_group="$2"
  local new_name="$3"
  local new_host_type="$4"
  local new_host="$5"
  local new_port="$6"
  local new_username="$7"
  local new_auth_type="$8"
  local new_credential="$9"

  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" \
     --arg group "$new_group" \
     --arg name "$new_name" \
     --arg host_type "$new_host_type" \
     --arg host "$new_host" \
     --arg port "$new_port" \
     --arg username "$new_username" \
     --arg auth_type "$new_auth_type" \
     --arg credential "$new_credential" \
     '
      .connections[$i].group        = $group
      | .connections[$i].name       = $name
      | .connections[$i].host_type  = $host_type
      | .connections[$i].host       = $host
      | .connections[$i].port       = ($port | tonumber)
      | .connections[$i].username   = $username
      | .connections[$i].auth_type  = $auth_type
      | .connections[$i].credential = $credential
     ' "$CONFIG_FILE"
}

##
# ì„ íƒëœ connectionì„ ì‚­ì œí•œ ìƒˆë¡œìš´ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Delete the selected connection from the list and output the updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_delete() {
  local selected_json="$1"
  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" 'del(.connections[$i])' "$CONFIG_FILE"
}

##
# ì„ íƒëœ connectionì˜ groupë§Œ ìƒˆ ê°’ìœ¼ë¡œ ë³€ê²½í•œ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Change only the group of the selected connection and output the updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
# @param $2 {string} new_group ìƒˆ group ê°’ / new group value
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_move_group() {
  local selected_json="$1"
  local new_group="$2"
  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" --arg group "$new_group" '
    .connections[$i].group = $group
  ' "$CONFIG_FILE"
}

# =======================================
# Commands
# =======================================

##
# ssh-cmd -l|--list-all [expr] ëª…ë ¹ì„ êµ¬í˜„í•œë‹¤.
# Implement ssh-cmd -l|--list-all [expr] command.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} print_connections_table ê²°ê³¼ ì½”ë“œ / result code from print_connections_table.
##
cmd_list() {
  local query="${1:-}"
  print_connections_table "$query"
}

##
# ìƒˆ SSH connection ì •ë³´ë¥¼ ì¸í„°ë™í‹°ë¸Œí•˜ê²Œ ì…ë ¥ í›„ configurationì— ì¶”ê°€í•œë‹¤.
# Add a new SSH connection interactively and append it to configuration.
#
# @param $1 ì—†ìŒ (ëª¨ë“  ì…ë ¥ì€ í”„ë¡¬í”„íŠ¸ë¡œ ë°›ìŒ) / none (all inputs are prompted interactively)
#
# @return {int} ì„±ê³µ ì‹œ 0, ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on validation or save failures.
##
cmd_add_connection() {
  ensure_config_file

  log INFO "ìƒˆ connection ì •ë³´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤."

  echo "-----------------------------------------------------------"

  local group name host_type host port username auth_type credential host_input port_input

  # group
  while true; do
    group="$(prompt_with_icon "ğŸ“" "group" "default")"
    if validate_non_empty "group" "$group"; then
      break
    fi
  done

  # name
  while true; do
    name="$(prompt_with_icon "ğŸ·" "name" "")"
    if validate_non_empty "name" "$name"; then
      break
    fi
  done

  # host_type
  while true; do
    host_type="$(prompt_with_icon "ğŸŒ" "host_type (ipv4|ipv6|domain)" "ipv4")"
    if validate_host_type "$host_type"; then
      break
    fi
  done

  # host (+ optional port)
  while true; do
    host_input="$(prompt_with_icon "ğŸ–¥" "host" "")"
    if [[ "$host_input" =~ ^(.+):([0-9]+)$ ]]; then
      host="${BASH_REMATCH[1]}"
      port_input="${BASH_REMATCH[2]}"
    else
      host="$host_input"
      port_input="22"
    fi
    if ! validate_non_empty "host" "$host"; then
      continue
    fi
    if ! validate_host_by_type "$host_type" "$host"; then
      continue
    fi
    break
  done

  # port
  while true; do
    port="$(prompt_with_icon "ğŸ”Œ" "port" "$port_input")"
    if validate_port "$port"; then
      break
    fi
  done

  # username
  while true; do
    username="$(prompt_with_icon "ğŸ‘¤" "username" "")"
    if validate_non_empty "username" "$username"; then
      break
    fi
  done

  # auth_type
  while true; do
    auth_type="$(prompt_with_icon "ğŸ”" "auth_type (password|key)" "key")"
    if validate_auth_type "$auth_type"; then
      break
    fi
  done

  if [[ "$auth_type" == "password" ]]; then
    while true; do
      read -r -s -p "â“  ğŸ”‘ password: " credential
      printf '\n'
      if validate_non_empty "password" "$credential"; then
        break
      fi
    done
  else
    while true; do
      read -r -e -p "â“  ğŸ”‘ key path: " credential
      credential="$(resolve_path_abs "$credential")"
      if validate_non_empty "key path" "$credential"; then
        break
      fi
    done
  fi

  echo "-----------------------------------------------------------"

  # 'ë¯¼ê°ì •ë³´' ì•”í˜¸í™” ì ìš©
  username_enc="$(encrypt_value "$username")"
  credential_enc="$(encrypt_value "$credential")"

  local new_json
  new_json="$(jq --arg group "$group" \
                 --arg name "$name" \
                 --arg host_type "$host_type" \
                 --arg host "$host" \
                 --arg port "$port" \
                 --arg username "$username_enc" \
                 --arg auth_type "$auth_type" \
                 --arg credential "$credential_enc" \
                 '
    .connections += [{
      "group": $group,
      "name": $name,
      "host_type": $host_type,
      "host": $host,
      "port": ($port | tonumber),
      "username": $username,
      "auth_type": $auth_type,
      "credential": $credential
    }]
  ' "$CONFIG_FILE")"

  save_connections_json <<< "$new_json"

  local raw_line="${group}\t${name}\t${host}\t${port}\t${username}\t${credential}"
  local temp_buffer="Group\tName\tHost\tPort\tUser\tCredential\n${raw_line}\n"

  if command -v column >/dev/null 2>&1; then
    local rendered header_line data_lines header_len eq_line dash_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"

    echo "$eq_line"
    echo "ìƒì„±ëœ connection:"
    echo "$header_line"
    echo "$dash_line"
    echo "$data_lines"
  else
    echo "=============================="
    echo "ìƒì„±ëœ connection:"
    print_single_connection_from_fields "$group" "$name" "$host" "$port" "$username" "$credential"
  fi

  # auth_type ì´ password ì¸ ê²½ìš°, configuration ì €ì¥ í›„ sshpass ìë™ ì„¤ì¹˜ ì‹œë„
  if [[ "$auth_type" == "password" ]]; then
    if ! command -v sshpass >/dev/null 2>&1; then
      echo "INFO: auth_type=password ì´ë¯€ë¡œ sshpass ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤." >&2
      if ! install_sshpass_if_missing; then
        echo "WARN: sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´í›„ password ê¸°ë°˜ ì ‘ì† ì‹œ sshpass ê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
      fi
    fi
  fi
}

##
# ê¸°ë³¸/ê²€ìƒ‰ expr ì— ë”°ë¼ ì‹¤ì œ SSH ì ‘ì†ì„ ìˆ˜í–‰í•œë‹¤.
# Perform actual SSH connection based on optional search expr (default/select & connect).
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} password ëª¨ë“œì—ì„œëŠ” ssh ë°˜í™˜ ì½”ë“œ, key ëª¨ë“œì—ì„œëŠ” exec ssh í›„ ë³µê·€í•˜ì§€ ì•ŠìŒ.
#         In password mode: ssh exit code; in key mode: exec ssh (no return).
##
cmd_connect() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  local host username port auth_type credential
  host="$(jq -r '.host' <<< "$selected_json")"
  username_enc="$(jq -r '.username' <<< "$selected_json")"
  username="$(decrypt_value_if_needed "$username_enc")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"
  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"
  credential_enc="$(jq -r '.credential' <<< "$selected_json")"
  credential="$(decrypt_value_if_needed "$credential_enc")"

  validate_port "$port" || die "port ê°’ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: $port"

  if [[ "$auth_type" == "password" ]]; then
    if ! command -v sshpass >/dev/null 2>&1; then
      echo "â—  sshpass ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•Šì•„, ì´ë²ˆ ì ‘ì†ì€ ì·¨ì†Œí•˜ê³  sshpass ì„¤ì¹˜ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤." >&2
      if ! install_sshpass_if_missing; then
        echo "â—  sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì„¤ì¹˜í•œ í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ ì£¼ì„¸ìš”." >&2
      fi
      return 1
    fi    
    echo 
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—                                          â—â—â—" >&2
    echo "â—â—â— ê²½ê³ : sshpass + password ë°©ì‹ ì ‘ì†ì…ë‹ˆë‹¤ â—â—â—" >&2
    echo "â—â—â—                                          â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo 
    sshpass -p "$credential" ssh -p "$port" "${username}@${host}"
  else
    if [[ ! -f "$credential" ]]; then
      die "key file not found: $credential"
    fi
    echo 
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”                                          ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ” ì•ˆì‹¬: 'OpenSSH Key ì¸ì¦ë°©ì‹' ì ‘ì†ì…ë‹ˆë‹¤. ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”                                          ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo 
    exec ssh -p "$port" -i "$credential" "${username}@${host}"
  fi
}

##
# ssh-cmd -m|--modify-connection [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì„ ìˆ˜ì •í•œë‹¤.
# Implement ssh-cmd -m|--modify-connection [expr] and modify a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„±ê³µ ì‹œ 0, ì„ íƒ/ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on selection/validation/save failures.
##
cmd_modify_connection() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  echo "-----------------------------------------------------------"

  local group name host_type host port username auth_type credential
  group="$(jq -r '.group' <<< "$selected_json")"
  name="$(jq -r '.name' <<< "$selected_json")"
  host_type="$(jq -r '.host_type' <<< "$selected_json")"
  host="$(jq -r '.host' <<< "$selected_json")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"

  # -------------------------------
  # â˜… username / credential ë³µí˜¸í™” ì ìš©
  # -------------------------------
  username_enc="$(jq -r '.username' <<< "$selected_json")"
  username="$(decrypt_value_if_needed "$username_enc")"
  credential_enc="$(jq -r '.credential' <<< "$selected_json")"
  credential="$(decrypt_value_if_needed "$credential_enc")"

  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"

  if [[ "$host" =~ ^(.+):([0-9]+)$ ]]; then
    host="${BASH_REMATCH[1]}"
    port="${BASH_REMATCH[2]}"
  fi

  local new_group new_name new_host_type new_host new_port new_username new_auth_type new_credential
  local host_input port_input tmp

  # group
  while true; do
    new_group="$(prompt_with_icon "ğŸ“" "group" "$group")"
    if [[ -z "$new_group" ]]; then
      new_group="$group"
    fi
    if validate_non_empty "group" "$new_group"; then
      break
    fi
  done

  # name
  while true; do
    new_name="$(prompt_with_icon "ğŸ·" "name" "$name")"
    if [[ -z "$new_name" ]]; then
      new_name="$name"
    fi
    if validate_non_empty "name" "$new_name"; then
      break
    fi
  done

  # host_type
  while true; do
    new_host_type="$(prompt_with_icon "ğŸŒ" "host_type (ipv4|ipv6|domain)" "$host_type")"
    if [[ -z "$new_host_type" ]]; then
      new_host_type="$host_type"
    fi
    if validate_host_type "$new_host_type"; then
      break
    fi
  done

  # host (+ optional port)
  while true; do
    host_input="$(prompt_with_icon "ğŸ–¥" "host" "$host")"
    if [[ -z "$host_input" ]]; then
      host_input="$host"
    fi
    if [[ "$host_input" =~ ^(.+):([0-9]+)$ ]]; then
      new_host="${BASH_REMATCH[1]}"
      port_input="${BASH_REMATCH[2]}"
    else
      new_host="$host_input"
      port_input="$port"
    fi
    if ! validate_non_empty "host" "$new_host"; then
      continue
    fi
    if ! validate_host_by_type "$new_host_type" "$new_host"; then
      continue
    fi
    break
  done

  # port
  while true; do
    new_port="$(prompt_with_icon "ğŸ”Œ" "port" "$port_input")"
    if [[ -z "$new_port" ]]; then
      new_port="$port"
    fi
    if validate_port "$new_port"; then
      break
    fi
  done

  # username
  while true; do
    new_username="$(prompt_with_icon "ğŸ‘¤" "username" "$username")"
    if [[ -z "$new_username" ]]; then
      new_username="$username"
    fi
    if validate_non_empty "username" "$new_username"; then
      break
    fi
  done

  # auth_type
  while true; do
    new_auth_type="$(prompt_with_icon "ğŸ”" "auth_type (password|key)" "$auth_type")"
    if [[ -z "$new_auth_type" ]]; then
      new_auth_type="$auth_type"
    fi
    if validate_auth_type "$new_auth_type"; then
      break
    fi
  done

  # credential
  if [[ "$new_auth_type" == "password" ]]; then
    local old_pw="$credential"
    while true; do
      read -r -s -p "â“  ğŸ”‘ password [****]: " tmp
      printf '\n'
      if [[ -z "$tmp" ]]; then
        new_credential="$old_pw"
        break
      fi
      new_credential="$tmp"
      break
    done
  else
    while true; do
      read -r -e -p "â“  ğŸ”‘ key path [${credential}]: " tmp
      if [[ -z "$tmp" ]]; then
        new_credential="$credential"
      else
        new_credential="$(resolve_path_abs "$tmp")"
      fi
      if validate_non_empty "key path" "$new_credential"; then
        break
      fi
    done
  fi

  echo "-----------------------------------------------------------"

  local new_json
  # -------------------------------
  # â˜… ì €ì¥ ì§ì „ ì•”í˜¸í™” ì ìš©
  # -------------------------------
  new_username_enc="$(encrypt_value "$new_username")"
  new_credential_enc="$(encrypt_value "$new_credential")"

  new_json="$(update_connection_modify "$selected_json" \
                  "$new_group" "$new_name" "$new_host_type" "$new_host" "$new_port" \
                  "$new_username_enc" "$new_auth_type" "$new_credential_enc")"

  save_connections_json <<< "$new_json"

  echo "ìˆ˜ì • í›„ connection:"
  print_single_connection_from_fields "$new_group" "$new_name" "$new_host" "$new_port" "$new_username" "$new_credential"
}

select_indices_for_delete() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0 group name host port user cred idx

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len dash_line eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$dash_line"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      display_cred="$(format_credential_for_display "$cred")"
      local display_idx
      printf -v display_idx "%04d" "$n"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred" >&2
    done <<< "$raw"
  fi

  # ë²ˆí˜¸ ì…ë ¥ (ì‰¼í‘œ êµ¬ë¶„)
  local sel
  while true; do
    read -r -p "â“  ì‚­ì œí•  ë²ˆí˜¸(#)ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 1, 2, 3): " sel
    sel="${sel//[[:space:]]/}"  # ê³µë°± ì œê±°

    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi

    if ! [[ "$sel" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
      echo "ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ìˆ«ìë§Œ ì…ë ¥í•˜ì„¸ìš”." >&2
      continue
    fi

    local -a nums=()
    IFS=',' read -r -a nums <<< "$sel"

    local ok=true
    local v
    for v in "${nums[@]}"; do
      if (( v < 1 || v > n )); then
        echo "ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: $v (1~$n)" >&2
        ok=false
      fi
    done
    $ok && break
  done

  # ì¤‘ë³µ ì œê±° + idx_map â†’ ì‹¤ì œ JSON index ë¡œ ë³€í™˜
  local -A seen=()
  local -a real_idx=()
  local v
  for v in "${nums[@]}"; do
    if [[ -n "${seen[$v]:-}" ]]; then
      continue
    fi
    seen[$v]=1
    real_idx+=( "${idx_map[$v]}" )
  done

  # stdout: JSON index ë“¤ì„ í•œ ì¤„ì”© ë°˜í™˜
  printf '%s\n' "${real_idx[@]}"
}


##
# ssh-cmd -d|--delete-connection [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì„ ì‚­ì œí•œë‹¤.
# Implement ssh-cmd -d|--delete-connection [expr] and delete a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì‚­ì œ ì™„ë£Œ ì‹œ 0, ì„ íƒ/í™•ì¸/ì €ì¥ ì‹¤íŒ¨ ë˜ëŠ” ì·¨ì†Œ ì‹œ ë¹„-0
#         0 on successful deletion; non-zero on failure or cancel.
##
cmd_delete_connection() {
  ensure_config_file

  local query="${1:-}"

  # 1) ì‚­ì œ ëŒ€ìƒ index (JSON ìƒì˜ __idx) ëª©ë¡ ì–»ê¸°
  local -a idxs=()
  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idxs+=( "$line" )
  done < <(select_indices_for_delete "$query") || return 1

  if (( ${#idxs[@]} == 0 )); then
    #echo "ì„ íƒëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤." >&2
    return 1
  fi

  # 2) "ì‚­ì œ ëŒ€ìƒ:" ë¯¸ë¦¬ë³´ê¸°
  echo "ì‚­ì œ ëŒ€ìƒ:"
  local preview_raw=""
  local idx
  for idx in "${idxs[@]}"; do
    local row
    row="$(jq -r --argjson i "$idx" '
      .connections
      | to_entries
      | .[$i]
      | "\(.value.group)\t\(.value.name)\t\(.value.host)\t\(.value.port // 22)\t\(.value.username)\t\(.value.credential)"
    ' "$CONFIG_FILE")"
    if [[ -n "$row" ]]; then
      preview_raw+="${row}"$'\n'
    fi
  done
  print_raw_as_table_no_index "$preview_raw"

  # 3) ìµœì¢… í™•ì¸
  local answer
  read -r -p "ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " answer
  case "$answer" in
    y|Y|yes|YES)
      # 4) í° indexë¶€í„° ì‚­ì œ (ì•ìª½ index ì˜í–¥ ìµœì†Œí™”)
      local sorted
      sorted="$(printf '%s\n' "${idxs[@]}" | sort -rn)"

      local i
      for i in $sorted; do
        local selected_json
        selected_json="$(jq -c --argjson j "$i" '
          .connections
          | to_entries
          | .[$j]
          | { __idx: .key } + .value
        ' "$CONFIG_FILE")" || continue

        local new_json
        new_json="$(update_connection_delete "$selected_json")"
        save_connections_json <<< "$new_json"
      done

      echo "ì‚­ì œ ì™„ë£Œ."
      ;;
    *)
      echo "ì‚­ì œ ì·¨ì†Œ."
      ;;
  esac
}

##
# ssh-cmd -mg|--move-group-connection [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì˜ groupì„ ë³€ê²½í•œë‹¤.
# Implement ssh-cmd -mg|--move-group-connection [expr] and change the group of a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„±ê³µ ì‹œ 0, ì„ íƒ/ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on selection/validation/save failures.
##
cmd_move_group_connection() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  echo "-----------------------------------------------------------"

  local current_group idx
  current_group="$(jq -r '.group' <<< "$selected_json")"
  idx="$(jq -r '.__idx'  <<< "$selected_json")"

  echo "í˜„ì¬ group: ${current_group}"

  local new_group
  while true; do
    new_group="$(prompt_with_icon "ğŸ“" "ìƒˆ group" "$current_group")"
    if [[ -z "$new_group" ]]; then
      new_group="$current_group"
    fi
    if validate_non_empty "group" "$new_group"; then
      break
    fi
  done

  echo "-----------------------------------------------------------"

  local new_json
  new_json="$(update_connection_move_group "$selected_json" "$new_group")"
  save_connections_json <<< "$new_json"

  echo "group ë³€ê²½ ì™„ë£Œ: ${current_group} â†’ ${new_group}"
  echo "ë³€ê²½ëœ connection:"

  local updated_json
  updated_json="$(jq -c --argjson i "$idx" '
    .connections
    | to_entries
    | .[$i]
    | { __idx: .key } + .value
  ' "$CONFIG_FILE")"
  print_connection_preview_from_json "$updated_json"
}

# =======================================
# main
# =======================================

##
# ssh-cmd ì—”íŠ¸ë¦¬í¬ì¸íŠ¸ í•¨ìˆ˜ë¡œ, ì „ì—­ ì˜µì…˜ê³¼ ì„œë¸Œì»¤ë§¨ë“œë¥¼ íŒŒì‹±í•˜ê³  ê° ëª…ë ¹ì„ ë””ìŠ¤íŒ¨ì¹˜í•œë‹¤.
# Entry point for ssh-cmd; parses global options and subcommands, then dispatches to handlers.
#
# @param $1..$n {string} CLI ì¸ì (ì˜ˆ: --config, -l, -a, -m ë“±) / CLI arguments (e.g. --config, -l, -a, -m)
#
# @return {int} ê° cmd_* í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ì½”ë“œ ë˜ëŠ” die() í˜¸ì¶œ ì‹œ exit 1
#         Exit code from the corresponding cmd_* function or 1 via die().
##
main() {
  ensure_dependencies

  # ê¸°ë³¸ê°’
  SHOW_CREDENTIAL="false"
  EXEC_CMD="connect"

  local arg_config=""
  local arg_masterkey=""
  local show_help="false"
  local -a positional_args=()

  # 0) ì „ì—­ ì˜µì…˜ íŒŒì‹±
  #    - --config <path>
  #    - -s / --show-credential
  #    - -h / --help
  #    â†’ ì¸ì ì „ì²´ë¥¼ í›‘ìœ¼ë©´ì„œ ì²˜ë¦¬í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” positional_args ì—ë§Œ ëª¨ì€ë‹¤.
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        shift || true
        if [[ $# -eq 0 ]]; then
          echo "[ERROR] --config ì˜µì…˜ì—ëŠ” ì„¤ì • íŒŒì¼ ê²½ë¡œê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
          exit 1
        fi
        arg_config="$1"
        shift
        ;;
      --masterkey)
        shift || true
        if [[ $# -eq 0 ]]; then
          echo "[ERROR] --masterkey ì˜µì…˜ì—ëŠ” masterkey(OpenSSH private key) íŒŒì¼ ê²½ë¡œê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
          exit 1
        fi
        arg_masterkey="$1"
        shift
        ;;
      -s|--show-credential)
        SHOW_CREDENTIAL="true"
        shift
        ;;
      -h|--help)
        show_help="true"
        shift
        ;;
      --)
        shift
        # '--' ì´í›„ëŠ” ëª¨ë‘ ìˆœìˆ˜ ì¸ìë¡œ ì „ë‹¬
        while [[ $# -gt 0 ]]; do
          positional_args+=("$1")
          shift
        done
        break
        ;;
      *)
        # ì „ì—­ ì˜µì…˜ì´ ì•„ë‹Œ ëª¨ë“  ì¸ìëŠ” ê·¸ëŒ€ë¡œ positional ì˜ì—­ì— ìŒ“ëŠ”ë‹¤.
        positional_args+=("$1")
        shift
        ;;
    esac
  done

  # ì „ì—­ ì˜µì…˜ì„ ì œê±°í•œ ë‚˜ë¨¸ì§€ ì¸ìë¥¼ ë³µì›
  if [[ ${#positional_args[@]} -gt 0 ]]; then
    set -- "${positional_args[@]}"
  else
    set --
  fi

  # -h / --help ê°€ í•œ ë²ˆì´ë¼ë„ ë“±ì¥í–ˆìœ¼ë©´, ë‚˜ë¨¸ì§€ ì¸ìì™€ ë¬´ê´€í•˜ê²Œ ë„ì›€ë§ ì¶œë ¥
  if [[ "$show_help" == "true" ]]; then
    help ""
    return 0
  fi

  # CONFIG_FILE ìš°ì„ ìˆœìœ„
  #  1) --config
  #  2) SSH_CMD_CONFIG í™˜ê²½ë³€ìˆ˜
  #  3) DEFAULT_CONFIG_FILE
  if [[ -n "$arg_config" ]]; then
    CONFIG_FILE="$arg_config"
  elif [[ -n "${SSH_CMD_CONFIG:-}" ]]; then
    CONFIG_FILE="${SSH_CMD_CONFIG}"
  fi

  # MASTERKEY_FILE ìš°ì„ ìˆœìœ„
  #  1) --masterkey
  #  2) SSH_CMD_MASTERKEY
  #  3) SSM_CMD_MASTERKEY (ì˜¤íƒ€/í˜¸í™˜ìš© ë³„ì¹­)
  #  4) MASTERKEY_DEFAULT
  if [[ -n "$arg_masterkey" ]]; then
    MASTERKEY_FILE="$arg_masterkey"
  elif [[ -n "${SSH_CMD_MASTERKEY:-}" ]]; then
    MASTERKEY_FILE="${SSH_CMD_MASTERKEY}"
  elif [[ -n "${SSM_CMD_MASTERKEY:-}" ]]; then
    MASTERKEY_FILE="${SSM_CMD_MASTERKEY}"
  fi

  # ì„¤ì • íŒŒì¼ ê²€ì¦
  ensure_config_file
  # open ssh key md5 ê²€ì¦
  ensure_masterkey_md5

  # ë‚¨ì€ ì¸ìê°€ ì—†ìœ¼ë©´: ssh-cmd [Enter] â†’ connect (masking list)
  if [[ $# -eq 0 ]]; then
    EXEC_CMD="connect"
    cmd_connect ""
    return 0
  fi

  local first="$1"

  # 1) ì–´ë–¤ ì„œë¸Œì»¤ë§¨ë“œë¥¼ ì‹¤í–‰í• ì§€ ê²°ì •
  case "$first" in
    --list|-l|--list-all)
      # [ì—°ê²°ì •ë³´ ëª©ë¡] ëª¨ë“œ
      EXEC_CMD="list"
      shift
      # ë‚¨ì€ ì²« ë²ˆì§¸ ì¸ìë¥¼ ê²€ìƒ‰ì‹(<expr>) ìœ¼ë¡œ ì‚¬ìš© (ì—†ìœ¼ë©´ ì „ì²´)
      cmd_list "${1:-}"
      ;;
    --add-connection|-a)
      # [ì—°ê²°ì •ë³´ ì¶”ê°€]
      EXEC_CMD="add"
      shift
      cmd_add_connection
      ;;
    --modify-connection|-m)
      # [ì—°ê²°ì •ë³´ ìˆ˜ì •] - plain list ì‚¬ìš©, -s ì˜µì…˜ì€ ì „ì—­ ì˜µì…˜ìœ¼ë¡œë§Œ ì²˜ë¦¬(í‘œì‹œ ë°©ì‹ì—ëŠ” ì˜í–¥ ì—†ìŒ)
      EXEC_CMD="modify"
      shift
      cmd_modify_connection "${1:-}"
      ;;
    --delete-connection|-d)
      # [ì—°ê²°ì •ë³´ ì‚­ì œ] - masking list ê³ ì •, -s ì˜µì…˜ ë¬´ì‹œ
      EXEC_CMD="delete"
      shift
      cmd_delete_connection "${1:-}"
      ;;
    --move-group-connection|-mg)
      # [ì—°ê²°ì •ë³´ ê·¸ë£¹ ì´ë™] - masking list ê³ ì •, -s ì˜µì…˜ ë¬´ì‹œ
      EXEC_CMD="move-group"
      shift
      cmd_move_group_connection "${1:-}"
      ;;
    --version)
      echo "ssh-cmd version ${APP_VERSION:-unknown}"
      return 0
      ;;
    -*)
      # ì¸ì‹ë˜ì§€ ì•ŠëŠ” ì˜µì…˜
      echo "Unknown option or command: $first" >&2
      exit 1
      ;;
    *)
      # ë‚˜ë¨¸ì§€ëŠ” ëª¨ë‘ [ì„œë²„ ì ‘ì†]ìœ¼ë¡œ ì²˜ë¦¬
      #   ssh-cmd <expr> â†’ <expr> ê²€ìƒ‰ê²°ê³¼ê°€ ì ìš©ëœ masking list ê¸°ë°˜ ì ‘ì†
      EXEC_CMD="connect"
      cmd_connect "$first"
      ;;
  esac
}

main "$@"

exit 0
