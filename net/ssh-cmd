#!/usr/bin/env bash
# =======================================
# @author   : parkjunhong77@gmail.com
# @title    : ssh-cmd
# @license  : Apache License 2.0
# @since    : 2025-12-09
# @desc     : support RHEL 7+/8+, Oracle Linux 7+/8+, Ubuntu 18.04+, CentOS 7+, ê¸°íƒ€ í‘œì¤€ bash + jq í™˜ê²½
# @installation :
#   1. insert 'source <path>/ssh-cmd" into ~/bin/.bashrc or ~/bin/.bash_profile for a personal usage.
#   2. copy the above file to /etc/bash_completion.d/ or insert 'source <path>/ssh-cmd' into
#      /etc/bashrc for all users.
# =======================================

set -euo pipefail

FILENAME="$(basename "$0")"

CONFIG_DIR="${HOME}/.ssh-cmd"
CONFIG_FILE="${CONFIG_DIR}/configuration"
LOG_LEVEL="${LOG_LEVEL:-INFO}"

PROMPT_LABEL_WIDTH=0

##
# ê³µí†µ help ì¶œë ¥.
# Common help output.
#
# @param $1 {string} cause
#   - ì—ëŸ¬/ì›ì¸ ë©”ì‹œì§€ (optional).
#   - Error / cause message (optional).
# @param $2 {string} line
#   - ì—ëŸ¬ ë°œìƒ ë¼ì¸ ë²ˆí˜¸ (optional).
#   - Line number where error occurred (optional).
#
# @return ì—†ìŒ. stdout/stderr ì— ë„ì›€ë§ ì¶œë ¥ í›„ ì¢…ë£Œ ì½”ë“œ(0 ë˜ëŠ” 1)ë¡œ ì¢…ë£Œ.
# @return none. Prints help to stdout/stderr then exits with status.
##
help() {
  if [ ! -z "${1:-}" ]; then
    local indent=10
    local formatl=" - %-"$indent"s: %s\n"
    local formatr=" - %"$indent"s: %s\n"
    echo
    echo "================================================================================"
    printf "$formatl" "filename" "$FILENAME"
    printf "$formatl" "line" "${2:-}"
    printf "$formatl" "callstack"
    local idx=1
    for func in ${FUNCNAME[@]:1}; do
      printf "$formatr" "[""$idx""]" "$func"
      ((idx++))
    done
    printf "$formatl" "cause" "$1"
    echo "================================================================================"
  fi
  echo
  cat <<EOF
Usage: $FILENAME [OPTIONS] [ENTRY_KEY | SEARCH_EXPR]

ssh ì—°ê²° ì •ë³´ë¥¼ JSON(configuration) íŒŒì¼ë¡œ ê´€ë¦¬í•˜ê³ ,
ê²€ìƒ‰/ì¡°íšŒ/ì¶”ê°€/ìˆ˜ì •/ì‚­ì œ/ê·¸ë£¹ ì´ë™/ì ‘ì†ì„ ì§€ì›í•˜ëŠ” CLI ë„êµ¬ì…ë‹ˆë‹¤.
This CLI manages SSH connection metadata in a JSON configuration file and supports
search/list/add/modify/delete/move-group/connect operations.

ê¸°ë³¸ ë™ì‘ (no option):
  $FILENAME <í‚¤ì›Œë“œ ë˜ëŠ” Entry Key>
    - ì¸ìê°€ ì˜µì…˜ì´ë©´: í•´ë‹¹ ì˜µì…˜ì— ë§ëŠ” ê¸°ëŠ¥ ì‹¤í–‰
    - ì¸ìê°€ ì˜µì…˜ì´ ì•„ë‹ˆë©´: ê²€ìƒ‰ì–´ë¡œ ê°„ì£¼ í›„ ëŒ€ìƒì„ ì„ íƒí•˜ì—¬ SSH ì ‘ì†

Options:
  -l, --list-all
      ëª¨ë“  connection ëª©ë¡ ì¶œë ¥ (ê²€ìƒ‰ í‘œí˜„ì‹ê³¼ í•¨ê»˜ ì‚¬ìš© ê°€ëŠ¥).
      List all connections (optionally filtered by search expression).

  -a, --add-connection
      ìƒˆë¡œìš´ connection ì •ë³´ ì¶”ê°€ (ì¸í„°ë™í‹°ë¸Œ ì…ë ¥).
      Add a new connection (interactive).

  -m, --modify-connection
      ê¸°ì¡´ connection ì •ë³´ ìˆ˜ì •.
      Modify an existing connection.

  -d, --delete-connection
      í•˜ë‚˜ ì´ìƒ connection ì‚­ì œ (ë‹¤ì¤‘ ì„ íƒ ì§€ì›).
      Delete one or more connections (multi-select).

  -mg, --move-group-connection
      ì„ íƒí•œ connection ì˜ group ì„ ë³€ê²½.
      Move selected connection(s) to another group.

  -s, --show-credential
      credential(ë¹„ë°€ë²ˆí˜¸/í‚¤ ê²½ë¡œ) ë¥¼ ì‹¤ì œ ê°’ìœ¼ë¡œ í‘œì‹œ.
      By default credentials are masked with fixed "****************".
      This option shows real credential values.

  -h, --help
      ì´ ë„ì›€ë§ ì¶œë ¥.
      Show this help.

Examples:
  $FILENAME
      â†’ ì¸í„°ë™í‹°ë¸Œë¡œ Entry ë¥¼ ì„ íƒ í›„ SSH ì ‘ì† (ê²€ìƒ‰ ì—†ì´ ì „ì²´ ëŒ€ìƒ).

  $FILENAME dev
      â†’ "dev" ë¥¼ ê²€ìƒ‰ì–´ë¡œ ì‚¬ìš©í•˜ì—¬ ëŒ€ìƒ ì„ íƒ í›„ SSH ì ‘ì†.

  $FILENAME --list-all "{git} or {nexus}"
      â†’ git ë˜ëŠ” nexus ê°€ í¬í•¨ëœ connection ëª©ë¡ ì¶œë ¥.

  $FILENAME --add-connection
      â†’ ìƒˆë¡œìš´ connection ì •ë³´ ì…ë ¥.

ê²€ìƒ‰ í‘œí˜„ì‹:
  - "{kw1} and {kw2} or {kw3}" í˜•íƒœì˜ í‘œí˜„ì‹ ì§€ì›.
  - "{{expr1} or {expr2}} and {expr3}" ì²˜ëŸ¼ ì¤‘ì²© {{ }} ê·¸ë£¹ ì§€ì›.
  - ìì„¸í•œ ë¬¸ë²•ì€ SR ë¬¸ì„œì˜ "ê²€ìƒ‰ í‘œí˜„ì‹ ë¬¸ë²•" ì„¹ì…˜ ì°¸ì¡°.
EOF
}

die() {
  local msg="${1:-unknown error}"
  local line="${2:-}"
  help "$msg" "$line"
  exit 1
}

trap 'die "Unhandled error" "$LINENO"' ERR

log() {
  local level="$1"
  shift
  local msg="$*"

  local order="ERROR WARN INFO DEBUG"
  local want="${LOG_LEVEL:-INFO}"
  local idx=0 want_idx=0 pos=0
  for l in $order; do
    if [[ "$l" == "$want" ]]; then
      want_idx=$idx
    fi
    if [[ "$l" == "$level" ]]; then
      pos=$idx
    fi
    idx=$((idx+1))
  done

  if (( pos <= want_idx )); then
    printf '[%s] %s\n' "$level" "$msg" >&2
  fi
}

ensure_config_dir() {
  if [[ ! -d "$CONFIG_DIR" ]]; then
    mkdir -p "$CONFIG_DIR"
  fi
}

ensure_config_file() {
  ensure_config_dir
  if [[ ! -f "$CONFIG_FILE" ]]; then
    cat > "$CONFIG_FILE" <<EOF
{
  "connections": []
}
EOF
  fi
}

ensure_dependencies() {
  local missing=()
  command -v jq >/dev/null 2>&1 || missing+=("jq")

  if (( ${#missing[@]} > 0 )); then
    die "missing commands: ${missing[*]}"
  fi
}

##
# sshpass í”„ë¡œê·¸ë¨ì´ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ì—†ìœ¼ë©´ ìë™ ì„¤ì¹˜ë¥¼ ì‹œë„í•œë‹¤.
# Ensure sshpass is installed; try to install it automatically when missing.
#
# @param $1 {string} reason
#   - í˜¸ì¶œ ë§¥ë½ ì •ë³´ (ì˜ˆ: "add-connection", "connect").
#   - Context label for logging.
#
# @return {number}
#   - 0: sshpass ì‚¬ìš© ê°€ëŠ¥.
#   - 1: ì„¤ì¹˜ ì‹¤íŒ¨ ë˜ëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ” í™˜ê²½.
##
ensure_sshpass_installed() {
  local reason="${1:-}"

  if command -v sshpass >/dev/null 2>&1; then
    return 0
  fi

  log WARN "sshpass ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. (context: ${reason})"

  local pm=""
  if command -v apt-get >/dev/null 2>&1; then
    pm="apt-get"
  elif command -v dnf >/dev/null 2>&1; then
    pm="dnf"
  elif command -v yum >/dev/null 2>&1; then
    pm="yum"
  elif command -v zypper >/dev/null 2>&1; then
    pm="zypper"
  elif command -v apk >/dev/null 2>&1; then
    pm="apk"
  fi

  if [[ -z "$pm" ]]; then
    log ERROR "ì§€ì›ë˜ëŠ” íŒ¨í‚¤ì§€ ê´€ë¦¬ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ sshpass ë¥¼ ìë™ ì„¤ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    return 1
  fi

  log INFO "sshpass ìë™ ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤. (package manager: ${pm})"

  case "$pm" in
    apt-get)
      if ! sudo apt-get update -y >/dev/null 2>&1; then
        log WARN "apt-get update ì‹¤íŒ¨ (ë¬´ì‹œ)."
      fi
      if ! sudo apt-get install -y sshpass; then
        log ERROR "sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (apt-get)"
        return 1
      fi
      ;;
    dnf)
      if ! sudo dnf install -y sshpass; then
        log ERROR "sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (dnf)"
        return 1
      fi
      ;;
    yum)
      if ! sudo yum install -y sshpass; then
        log ERROR "sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (yum)"
        return 1
      fi
      ;;
    zypper)
      if ! sudo zypper install -y sshpass; then
        log ERROR "sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (zypper)"
        return 1
      fi
      ;;
    apk)
      if ! sudo apk add --no-cache sshpass; then
        log ERROR "sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (apk)"
        return 1
      fi
      ;;
    *)
      log ERROR "ì•Œ ìˆ˜ ì—†ëŠ” íŒ¨í‚¤ì§€ ê´€ë¦¬ì: ${pm}"
      return 1
      ;;
  esac

  if command -v sshpass >/dev/null 2>&1; then
    log INFO "sshpass ì„¤ì¹˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
    return 0
  else
    log ERROR "sshpass ì„¤ì¹˜ í›„ì—ë„ ëª…ë ¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    return 1
  fi
}

mask_credential() {
  local show="${SHOW_CREDENTIAL:-0}"
  local value="$1"

  if [[ "$show" == "1" ]]; then
    echo "$value"
  else
    echo "****************"
  fi
}

validate_non_empty() {
  local value="$1"
  local field="$2"

  if [[ -z "$value" ]]; then
    echo "â—  ${field} ê°’ì€ ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi
}

validate_port() {
  local port="$1"

  if ! [[ "$port" =~ ^[0-9]+$ ]]; then
    echo "â—  port ëŠ” ìˆ«ìë§Œ í—ˆìš©ë©ë‹ˆë‹¤: $port" >&2
    return 1
  fi

  if (( port < 1 || port > 65535 )); then
    echo "â—  port ê°’ì€ 1~65535 ë²”ìœ„ì—¬ì•¼ í•©ë‹ˆë‹¤: $port" >&2
    return 1
  fi
}

validate_auth_type() {
  local auth_type="$1"

  case "$auth_type" in
    password|key)
      return 0
      ;;
    *)
      echo "â—  auth_type ì€ password ë˜ëŠ” key ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤: $auth_type" >&2
      return 1
      ;;
  esac
}

validate_file_exists() {
  local path="$1"
  local field="$2"

  if [[ ! -f "$path" ]]; then
    echo "â—  ${field} íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: $path" >&2
    return 1
  fi
}

init_prompt_label_width() {
  local fields=(
    "group"
    "name"
    "host"
    "port"
    "username"
    "auth_type"
    "credential"
  )
  local max_len=0
  local f
  for f in "${fields[@]}"; do
    local len=${#f}
    if (( len > max_len )); then
      max_len=$len
    fi
  done
  PROMPT_LABEL_WIDTH=$((max_len + 4))
}

prompt_with_default() {
  local label="$1"
  local default="$2"
  local var_name="$3"

  local current="$default"
  local var

  if [[ -n "$current" ]]; then
    printf -v label "%-${PROMPT_LABEL_WIDTH}s" "$label"
    read -r -p "â“  ${label} [${current}]: " var
    if [[ -z "$var" ]]; then
      var="$current"
    fi
  else
    printf -v label "%-${PROMPT_LABEL_WIDTH}s" "$label"
    read -r -p "â“  ${label}: " var
  fi

  printf -v "$var_name" '%s' "$var"
}

prompt_with_icon() {
  local icon="$1"
  local field="$2"
  local default="$3"
  local var_name="$4"

  local label
  printf -v label "%s  %s" "$icon" "$field"
  label="$(printf "%-${PROMPT_LABEL_WIDTH}s" "$label")"

  local current="$default"
  local input

  if [[ -n "$current" ]]; then
    read -r -p "â“  ${label} [${current}]: " input
    if [[ -z "$input" ]]; then
      input="$current"
    fi
  else
    read -r -p "â“  ${label}: " input
  fi

  printf -v "$var_name" '%s' "$input"
}

build_single_condition() {
  local kw="$1"
  kw="${kw#"${kw%%[![:space:]]*}"}"
  kw="${kw%"${kw##*[![:space:]]}"}"

  if [[ -z "$kw" ]]; then
    echo "true"
    return 0
  fi

  kw="${kw//\"/\\\"}"

  cat <<EOF
(.group      | tostring | ascii_downcase | contains("${kw}"))
or (.name    | tostring | ascii_downcase | contains("${kw}"))
or (.host    | tostring | ascii_downcase | contains("${kw}"))
or (.username| tostring | ascii_downcase | contains("${kw}"))
EOF
}

##
# ê²€ìƒ‰ í‘œí˜„ì‹ì—ì„œ jq filter ë¬¸ìì—´ì„ ìƒì„±í•œë‹¤.
# Build jq filter string from a logical search expression.
#
# @param $1 {string} expr
#   - ê²€ìƒ‰ì‹. ì˜ˆ) "{git} or {nexus}", "{{com} and {git}} or {{rep} and {nexus}}"
#   - Search expression with {keyword}, "and", "or" and nested {{ }} groups.
#
# @return {string}
#   - jq ì—ì„œ ì‚¬ìš©í•  boolean filter í‘œí˜„ì‹. ë¹„ì–´ ìˆëŠ” ê²½ìš° "true".
#   - Boolean jq filter string. Returns "true" when expr is empty.
##
build_search_filter() {
  local expr="$1"

  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  if [[ -z "$expr" ]]; then
    echo "true"
    return 0
  fi

  _build_search_filter_inner "$expr"
}

##
# ì¤‘ì²© ì¤‘ê´„í˜¸ë¥¼ ì§€ì›í•˜ëŠ” ì¬ê·€ íŒŒì„œ.
# Internal recursive parser that supports nested braces.
#
# ê·œì¹™ (Rules)
# - "{kw}"          : ë‹¨ì¼ ì¡°ê±´ (single condition)
# - "{kw1} and {kw2}": ë…¼ë¦¬ AND
# - "{kw1} or {kw2}" : ë…¼ë¦¬ OR
# - "{{expr}}"      : expr ë¶€ë¶„ì„ ì¬ê·€ íŒŒì‹± (nested group)
#
# @param $1 {string} expr
#   - íŒŒì‹± ëŒ€ìƒ ì „ì²´ í‘œí˜„ì‹.
#   - The expression segment to parse.
#
# @return {string}
#   - jq boolean filter ë¬¸ìì—´.
#   - jq boolean filter string.
##
_build_search_filter_inner() {
  local expr="$1"

  expr="${expr,,}"
  expr="$(printf '%s' "$expr" | tr -s '[:space:]' ' ')"
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  local conds=()
  local ops=()
  local rest="$expr"

  while [[ -n "$rest" ]]; do
    rest="${rest#"${rest%%[![:space:]]*}"}"
    [[ -z "$rest" ]] && break

    if [[ "${rest:0:1}" == "{" ]]; then
      local depth=0
      local len=${#rest}
      local i
      for ((i=0; i<len; i++)); do
        local ch="${rest:i:1}"
        if [[ "$ch" == "{" ]]; then
          depth=$((depth+1))
        elif [[ "$ch" == "}" ]]; then
          depth=$((depth-1))
          if (( depth == 0 )); then
            break
          fi
        fi
      done

      if (( depth != 0 )); then
        printf '%s\n' "$(build_single_condition "$expr")"
        return 0
      fi

      local close_pos="$i"
      local inner_len=$((close_pos - 1))
      local inside="${rest:1:inner_len}"
      local next_pos=$((close_pos + 1))
      local remaining="${rest:next_pos}"

      if [[ "$inside" == *"{"* ]]; then
        local sub_filter
        sub_filter="$(_build_search_filter_inner "$inside")" || return 1
        conds+=( "(${sub_filter})" )
      else
        conds+=( "$(build_single_condition "$inside")" )
      fi

      rest="$remaining"
    else
      local token="${rest%% *}"
      local remaining="${rest#* }"
      if [[ "$token" == "$rest" ]]; then
        remaining=""
      fi
      conds+=( "$(build_single_condition "$token")" )
      rest="$remaining"
    fi

    rest="${rest#"${rest%%[![:space:]]*}"}"
    if [[ "$rest" =~ ^(and|or)[[:space:]]+(.*)$ ]]; then
      ops+=( "${BASH_REMATCH[1]}" )
      rest="${BASH_REMATCH[2]}"
    else
      break
    fi
  done

  if (( ${#conds[@]} == 0 )); then
    printf '%s\n' "$(build_single_condition "$expr")"
    return 0
  fi

  local result="${conds[0]}"
  local i
  for ((i=0; i<${#ops[@]}; i++)); do
    local op="${ops[$i]}"
    local rhs="${conds[$((i+1))]}"
    result="(${result} ${op} ${rhs})"
  done

  printf '%s\n' "$result"
}

# =======================================
# List / selection helpers
# =======================================

_get_filtered_raw_connections() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  jq -r '
    .connections
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)"
  ' "$CONFIG_FILE"
}

print_raw_as_table() {
  local raw="$1"

  if [[ -z "$raw" ]]; then
    echo "No connections." >&2
    return 1
  fi

  if command -v column >/dev/null 2>&1; then
    local buffer=""
    local group name host port user cred
    local idx=0

    buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      idx=$((idx+1))
      local masked
      masked="$(mask_credential "$cred")"
      buffer+=$(printf "%04d\t%s\t%s\t%s\t%s\t%s\t%s\n" "$idx" "$group" "$name" "$host" "$port" "$user" "$masked")
      buffer+=$'\n'
    done <<< "$raw"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"
  else
    echo "=============================================================="
    printf "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential"
    printf "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------"

    local group name host port user cred
    local idx=0
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      idx=$((idx+1))
      local masked
      masked="$(mask_credential "$cred")"
      printf "%04d\t%s\t%s\t%s\t%s\t%s\t%s\n" "$idx" "$group" "$name" "$host" "$port" "$user" "$masked"
    done <<< "$raw"
    echo "=============================================================="
  fi

  return 0
}

print_raw_as_table_no_index() {
  local raw="$1"

  if [[ -z "$raw" ]]; then
    echo "No connections." >&2
    return 1
  fi

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    local group name host port user cred

    temp_buffer+="Group\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      temp_buffer+="${group}\t${name}\t${host}\t${port}\t${user}\t${cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len dash_line eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$dash_line"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"
  else
    local eq_line="=============================================================="

    echo "$eq_line"
    printf "%s\t%s\t%s\t%s\t%s\t%s\n" "Group" "Name" "Host" "Port" "User" "Credential"
    printf "%s\t%s\t%s\t%s\t%s\t%s\n" "-----" "----" "----" "----" "----" "----------"

    local group name host port user cred
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$group" "$name" "$host" "$port" "$user" "$cred"
    done <<< "$raw"
    echo "$eq_line"
  fi

  return 0
}

print_connections_table() {
  local query="${1:-}"
  local raw
  raw="$(_get_filtered_raw_connections "$query")"
  print_raw_as_table_no_index "$raw"
}

##
# ì‚­ì œìš©ìœ¼ë¡œ ë‹¤ì¤‘ ì—°ê²°ì„ ì„ íƒí•œë‹¤.
# Select multiple connections (for delete) by index number.
#
# @param $1 {string}
#   - ê²€ìƒ‰ í‘œí˜„ì‹ (query expression). ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ ëŒ€ìƒ.
#   - Search expression. When empty, all connections are candidates.
#
# @return {string}
#   - stdout ë¡œ JSON array index (__idx) ë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ì¶œë ¥.
#   - Prints JSON array indices (__idx) to stdout, one per line.
##
select_indices_for_delete() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0
  local group name host port user cred idx

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user}\t${cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$separator"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user" "$cred" >&2
    done <<< "$raw"
  fi

  local sel
  while true; do
    read -r -p "â“  ì‚­ì œí•  ë²ˆí˜¸(#)ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 1,3,5): " sel
    sel="${sel//[[:space:]]/}"

    if [[ -z "$sel" ]]; then
      echo "â—  ì‚­ì œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi

    if ! [[ "$sel" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
      echo "â—  ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ìˆ«ìë§Œ ì…ë ¥í•˜ì„¸ìš”." >&2
      continue
    fi

    local -a nums=()
    IFS=',' read -r -a nums <<< "$sel"

    local ok=true v
    for v in "${nums[@]}"; do
      if (( v < 1 || v > n )); then
        echo "â—  ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: $v (1~$n)" >&2
        ok=false
      fi
    done
    $ok && break
  done

  local -A seen=()
  local -a real_idx=()
  local v
  for v in "${nums[@]}"; do
    if [[ -n "${seen[$v]:-}" ]]; then
      continue
    fi
    seen[$v]=1
    real_idx+=( "${idx_map[$v]}" )
  done

  printf '%s\n' "${real_idx[@]}"
}

select_connection_interactively() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0
  local group name host port user cred idx

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      idx_map[$n]="$idx"

      local masked
      masked="$(mask_credential "$cred")"
      local display_idx
      printf -v display_idx "%04d" "$n"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user}\t${masked}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$separator"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      idx_map[$n]="$idx"

      local masked
      masked="$(mask_credential "$cred")"
      local display_idx
      printf -v display_idx "%04d" "$n"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user" "$masked" >&2
    done <<< "$raw"
  fi

  local sel
  while true; do
    read -r -p "â“  ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” (ì˜ˆ: 1, 2, 3): " sel

    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      exit 0
    fi

    if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
      echo "â—  ì…ë ¥í•œ ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” (ì˜ˆ: 1, 2, 3): " >&2
      continue
    fi
    if (( sel < 1 || sel > n )); then
      echo "â—  ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. 1~$n ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”." >&2
      continue
    fi
    break
  done

  local selected_idx="${idx_map[$sel]}"

  jq -c --argjson idx "$selected_idx" '
    .connections
    | to_entries
    | .[$idx]
    | { __idx: .key } + .value
  ' "$CONFIG_FILE"
}

update_connection_add() {
  local new_entry="$1"

  jq -c --argjson new "$new_entry" '
    .connections += [$new]
  ' "$CONFIG_FILE"
}

update_connection_modify() {
  local updated="$1"

  jq -c --argjson updated "$updated" '
    .connections
    | to_entries
    | map(if .key == $updated.__idx then .value = ($updated | del(.__idx)) else . end)
    | { connections: map(.value) }
  ' "$CONFIG_FILE"
}

update_connection_delete() {
  local target="$1"

  jq -c --argjson target "$target" '
    .connections
    | to_entries
    | map(select(.key != $target.__idx))
    | { connections: map(.value) }
  ' "$CONFIG_FILE"
}

update_connection_move_group() {
  local target="$1"
  local new_group="$2"

  jq -c --argjson target "$target" --arg group "$new_group" '
    .connections
    | to_entries
    | map(if .key == $target.__idx
          then .value.group = $group | .
          else .
          end)
    | { connections: map(.value) }
  ' "$CONFIG_FILE"
}

save_connections_json() {
  cat > "$CONFIG_FILE"
}

cmd_list_all() {
  local query="${1:-}"
  local raw
  raw="$(_get_filtered_raw_connections "$query")"
  print_raw_as_table "$raw"
}

cmd_add_connection() {
  ensure_config_file
  init_prompt_label_width

  log INFO "ìƒˆ connection ì •ë³´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤."

  local group="default"
  local name=""
  local host=""
  local port="22"
  local username=""
  local auth_type="password"
  local credential=""

  prompt_with_icon "ğŸ—‚" "group" "$group" group
  validate_non_empty "$group" "group" || return 1

  prompt_with_icon "ğŸ·" "name" "$name" name
  validate_non_empty "$name" "name" || return 1

  prompt_with_icon "ğŸŒ" "host" "$host" host
  validate_non_empty "$host" "host" || return 1

  prompt_with_icon "ğŸ”Œ" "port" "$port" port
  validate_port "$port" || return 1

  prompt_with_icon "ğŸ‘¤" "username" "$username" username
  validate_non_empty "$username" "username" || return 1

  prompt_with_icon "ğŸ”" "auth_type(password/key)" "$auth_type" auth_type
  validate_auth_type "$auth_type" || return 1

  case "$auth_type" in
    password)
      while true; do
        read -r -s -p "â“  ğŸ”‘ password: " credential
        echo
        read -r -s -p "â“  ğŸ”‘ password(again): " confirm
        echo
        if [[ "$credential" != "$confirm" ]]; then
          echo "â—  password ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì…ë ¥í•˜ì„¸ìš”." >&2
        else
          break
        fi
      done
      validate_non_empty "$credential" "password" || return 1
      ;;
    key)
      read -r -e -p "â“  ğŸ”‘ key path: " credential
      validate_file_exists "$credential" "key" || return 1
      ;;
  esac

  local new_entry
  new_entry="$(jq -n \
    --arg group "$group" \
    --arg name "$name" \
    --arg host "$host" \
    --argjson port "$port" \
    --arg username "$username" \
    --arg auth_type "$auth_type" \
    --arg credential "$credential" \
    '{
      "group": $group,
      "name": $name,
      "host": $host,
      "port": $port,
      "username": $username,
      "auth_type": $auth_type,
      "credential": $credential
    }')"

  local new_json
  new_json="$(update_connection_add "$new_entry")"
  save_connections_json <<< "$new_json"

  if [[ "$auth_type" == "password" ]]; then
    if ! ensure_sshpass_installed "add-connection"; then
      log WARN "sshpass ìë™ ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. password ë°©ì‹ ì ‘ì† ì‹œ ìˆ˜ë™ ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤."
    fi
  fi

  echo "connection ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."
}

cmd_modify_connection() {
  ensure_config_file
  init_prompt_label_width

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  local group name host port username auth_type credential
  group="$(jq -r '.group' <<< "$selected_json")"
  name="$(jq -r '.name' <<< "$selected_json")"
  host="$(jq -r '.host' <<< "$selected_json")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"
  username="$(jq -r '.username' <<< "$selected_json")"
  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"
  credential="$(jq -r '.credential' <<< "$selected_json")"

  prompt_with_icon "ğŸ—‚" "group" "$group" group
  validate_non_empty "$group" "group" || return 1

  prompt_with_icon "ğŸ·" "name" "$name" name
  validate_non_empty "$name" "name" || return 1

  prompt_with_icon "ğŸŒ" "host" "$host" host
  validate_non_empty "$host" "host" || return 1

  prompt_with_icon "ğŸ”Œ" "port" "$port" port
  validate_port "$port" || return 1

  prompt_with_icon "ğŸ‘¤" "username" "$username" username
  validate_non_empty "$username" "username" || return 1

  prompt_with_icon "ğŸ”" "auth_type(password/key)" "$auth_type" auth_type
  validate_auth_type "$auth_type" || return 1

  case "$auth_type" in
    password)
      echo "í˜„ì¬ password ëŠ” [****************] ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤."
      echo "[Enter] ë§Œ ì…ë ¥í•˜ë©´ ê¸°ì¡´ password ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤."
      local pw1 pw2
      read -r -s -p "â“  ğŸ”‘ new password (empty: keep current): " pw1
      echo
      if [[ -n "$pw1" ]]; then
        read -r -s -p "â“  ğŸ”‘ new password(again): " pw2
        echo
        if [[ "$pw1" != "$pw2" ]]; then
          echo "â—  password ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìˆ˜ì • ì‘ì—…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤." >&2
          return 1
        fi
        credential="$pw1"
      fi
      ;;
    key)
      echo "í˜„ì¬ key path ëŠ” [****************] ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤."
      read -r -e -p "â“  ğŸ”‘ new key path (empty: keep current): " new_key
      if [[ -n "$new_key" ]]; then
        validate_file_exists "$new_key" "key" || return 1
        credential="$new_key"
      fi
      ;;
  esac

  local updated
  updated="$(jq -n \
    --argjson idx "$idx" \
    --arg group "$group" \
    --arg name "$name" \
    --arg host "$host" \
    --argjson port "$port" \
    --arg username "$username" \
    --arg auth_type "$auth_type" \
    --arg credential "$credential" \
    '{
      "__idx": $idx,
      "group": $group,
      "name": $name,
      "host": $host,
      "port": $port,
      "username": $username,
      "auth_type": $auth_type,
      "credential": $credential
    }')"

  local new_json
  new_json="$(update_connection_modify "$updated")"
  save_connections_json <<< "$new_json"

  echo "connection ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤."
}

cmd_delete_connection() {
  ensure_config_file

  local query="${1:-}"

  local -a idxs=()
  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idxs+=( "$line" )
  done < <(select_indices_for_delete "$query") || return 1

  if (( ${#idxs[@]} == 0 )); then
    echo "ì„ íƒëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤." >&2
    return 1
  fi

  echo "ì‚­ì œ ëŒ€ìƒ:"
  local preview_raw=""
  local idx
  for idx in "${idxs[@]}"; do
    local row
    row="$(jq -r --argjson i "$idx" '
      .connections
      | to_entries
      | .[$i]
      | "\(.value.group)\t\(.value.name)\t\(.value.host)\t\(.value.port // 22)\t\(.value.username)\t\(.value.credential)"
    ' "$CONFIG_FILE")"
    if [[ -n "$row" ]]; then
      preview_raw+="${row}"$'\n'
    fi
  done
  print_raw_as_table_no_index "$preview_raw"

  local answer
  read -r -p "â“  ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " answer
  case "$answer" in
    y|Y|yes|YES)
      local sorted
      sorted="$(printf '%s\n' "${idxs[@]}" | sort -rn)"

      local i
      for i in $sorted; do
        local selected_json
        selected_json="$(jq -c --argjson j "$i" '
          .connections
          | to_entries
          | .[$j]
          | { __idx: .key } + .value
        ' "$CONFIG_FILE")" || continue

        local new_json
        new_json="$(update_connection_delete "$selected_json")"
        save_connections_json <<< "$new_json"
      done

      echo "ì‚­ì œ ì™„ë£Œ."
      ;;
    *)
      echo "ì‚­ì œ ì·¨ì†Œ."
      ;;
  esac
}

cmd_move_group_connection() {
  ensure_config_file
  init_prompt_label_width

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  local current_group
  current_group="$(jq -r '.group' <<< "$selected_json")"

  local new_group=""
  prompt_with_icon "ğŸ—‚" "new group" "$current_group" new_group
  validate_non_empty "$new_group" "new group" || return 1

  local updated_json
  updated_json="$(update_connection_move_group "$selected_json" "$new_group")"
  save_connections_json <<< "$updated_json"

  echo "connection ì˜ group ì´ '${current_group}' â†’ '${new_group}' ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤."
}

cmd_connect() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  local host username port auth_type credential
  host="$(jq -r '.host' <<< "$selected_json")"
  username="$(jq -r '.username' <<< "$selected_json")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"
  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"
  credential="$(jq -r '.credential' <<< "$selected_json")"

  validate_port "$port" || die "port ê°’ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: $port"

  if [[ "$auth_type" == "password" ]]; then
    echo "ê²½ê³ : password + sshpass ë°©ì‹ ì ‘ì†ì…ë‹ˆë‹¤." >&2

    if ! command -v sshpass >/dev/null 2>&1; then
      if ! ensure_sshpass_installed "connect"; then
        echo "â—  sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í•˜ì—¬ ì ‘ì†ì„ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." >&2
        return 1
      fi
      echo "â—  sshpass ë¥¼ ìƒˆë¡œ ì„¤ì¹˜í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ssh-cmd ë¥¼ ì‹¤í–‰í•˜ì—¬ ì ‘ì†ì„ ì‹œë„í•˜ì„¸ìš”." >&2
      return 0
    fi

    sshpass -p "$credential" ssh -p "$port" "${username}@${host}"
  else
    if [[ ! -f "$credential" ]]; then
      die "key file not found: $credential"
    fi
    exec ssh -p "$port" -i "$credential" "${username}@${host}"
  fi
}

parse_args() {
  local positional=()
  while (( "$#" )); do
    case "$1" in
      -l|--list-all)
        CMD_ACTION="list-all"
        ;;
      -a|--add-connection)
        CMD_ACTION="add-connection"
        ;;
      -m|--modify-connection)
        CMD_ACTION="modify-connection"
        ;;
      -d|--delete-connection)
        CMD_ACTION="delete-connection"
        ;;
      -mg|--move-group-connection)
        CMD_ACTION="move-group-connection"
        ;;
      -s|--show-credential)
        SHOW_CREDENTIAL=1
        ;;
      -h|--help)
        CMD_ACTION="help"
        ;;
      --)
        shift
        while (( "$#" )); do
          positional+=("$1")
          shift
        done
        break
        ;;
      -*)
        die "Unknown option: $1"
        ;;
      *)
        positional+=("$1")
        ;;
    esac
    shift || true
  done

  ARGS_POS=("${positional[@]}")
}

main() {
  ensure_dependencies
  ensure_config_file

  CMD_ACTION=""
  SHOW_CREDENTIAL=0
  ARGS_POS=()

  parse_args "$@"

  if [[ "${CMD_ACTION:-}" == "help" ]]; then
    help
    exit 0
  fi

  init_prompt_label_width

  case "${CMD_ACTION:-}" in
    "list-all")
      local query="${ARGS_POS[0]:-}"
      cmd_list_all "$query"
      ;;
    "add-connection")
      cmd_add_connection
      ;;
    "modify-connection")
      local query="${ARGS_POS[0]:-}"
      cmd_modify_connection "$query"
      ;;
    "delete-connection")
      local query="${ARGS_POS[0]:-}"
      cmd_delete_connection "$query"
      ;;
    "move-group-connection")
      local query="${ARGS_POS[0]:-}"
      cmd_move_group_connection "$query"
      ;;
    "")
      local first="${ARGS_POS[0]:-}"
      if [[ -z "$first" ]]; then
        cmd_connect ""
      else
        case "$first" in
          -*) 
            die "Unknown option or missing command: $first"
            ;;
          *)
            cmd_connect "$first"
            ;;
        esac
      fi
      ;;
    *)
      die "Unknown command internal state: ${CMD_ACTION}"
      ;;
  esac
}

main "$@"
exit 0
