#!/usr/bin/env bash
set -euo pipefail

# =======================================
# @author   : parkjunhong77@gmail.com
# @title    : sshctl: SSH connection manager
# @license  : Apache License 2.0
# @since    : 2025-12-09
# @desc     : support RHEL 7+/8+, Oracle Linux 7+/8+, Ubuntu 20.04+/22.04+/24.04+, CentOS 7+
# @installation :
#   1. insert 'source <path>/sshctl' into ~/bin/.bashrc or ~/bin/.bash_profile for a personal usage.
#   2. copy this file to /usr/local/bin/ or any directory in $PATH for all users.
# =======================================

FILENAME="$(basename "$0")"

# ê¸°ë³¸ ì„¤ì • íŒŒì¼ ê²½ë¡œ (Default configuration file path)
DEFAULT_CONFIG_DIR="${HOME}/.sshctl"
DEFAULT_CONFIG_FILE="${DEFAULT_CONFIG_DIR}/configuration"

# ì„¤ì • ë””ë ‰í† ë¦¬ / íŒŒì¼
CONFIG_DIR="${HOME}/.sshctl"
CONFIG_FILE="${CONFIG_DIR}/configuration.conf"
CONFIG_VERSION="1.0"

# masterkey (OpenSSH private key) ê¸°ë³¸ ê²½ë¡œ ë° ì‹¤ì œ ì‚¬ìš© ê²½ë¡œ
MASTERKEY_DEFAULT="${HOME}/.sshctl/masterkey.pem"
MASTERKEY_FILE="${MASTERKEY_DEFAULT}"

# í”„ë¡¬í”„íŠ¸ ë¼ë²¨ í­ (ì•„ì´ì½˜+í•„ë“œëª… ê³ ì • í­)
PROMPT_LABEL_WIDTH=32

# credential í‘œì‹œ ì œì–´ (ê¸°ë³¸: ë§ˆìŠ¤í‚¹, --show-credential/-s ë¡œ í‰ë¬¸ í‘œì‹œ)
SHOW_CREDENTIAL="false"

# ë°”ë¡œ ì ‘ì† ë²ˆí˜¸ ì§€ì • (connect mode only)
# - í•œêµ­ì–´/English: direct connect by selecting N-th item from filtered list
CONNECT_NUMBER=""

# =======================================
# help / usage
# =======================================

##
# sshctl ì „ì²´ ì‚¬ìš©ë²•ê³¼ ì—ëŸ¬ ì •ë³´ë¥¼ ì¶œë ¥í•œë‹¤.
# Print overall usage and diagnostic error information for sshctl.
#
# @param $1 {string|empty} ì—ëŸ¬/ì›ì¸ ë©”ì‹œì§€ (ì„ íƒ) / cause message (optional)
# @param $2 {int|empty} ì—ëŸ¬ ë°œìƒ ë¼ì¸ ë²ˆí˜¸ (ì„ íƒ) / line number where error occurred (optional)
#
# @return {int} í•­ìƒ 0ì„ ë°˜í™˜í•˜ì§€ë§Œ, ë³´í†µ die()ì—ì„œ í˜¸ì¶œëœ ë’¤ í”„ë¡œì„¸ìŠ¤ëŠ” exit 1ë¡œ ì¢…ë£Œë¨.
#         Always returns 0; typically invoked by die() and process exits with 1 afterwards.
##
help() {
  # $1: cause message (optional)
  # $2: line number (optional)
  if [ -n "${1:-}" ]; then
    local indent=10
    local formatl=" - %-"$indent"s: %s\n"
    local formatr=" - %"$indent"s: %s\n"
    echo
    echo "================================================================================"
    printf "$formatl" "filename" "$FILENAME"
    printf "$formatl" "line" "${2:-0}"
    printf "$formatl" "callstack"
    local idx=1
    for func in "${FUNCNAME[@]:1}"
    do
      printf "$formatr" "[$idx]" "$func"
      ((idx++))
    done
    printf "$formatl" "cause" "$1"
    echo "================================================================================"
  fi
  echo
  cat <<EOF
ì‚¬ìš©ë²• (Usage):
  sshctl [global-options]               # ê¸°ë³¸: ì „ì²´ ëª©ë¡ì—ì„œ ì„ íƒ í›„ ì ‘ì†
  sshctl [global-options] <expr>        # expr ë¡œ í•„í„°ë§ í›„ ì„ íƒ/ì ‘ì†
  sshctl [global-options] <expr> -n|--number <N>
  sshctl [global-options] -n|--number <N> [expr]
  sshctl [global-options] -l|--list-all [expr]
  sshctl [global-options] -a|--add-connection
  sshctl [global-options] -m|--modify-connection [expr]
  sshctl [global-options] -d|--delete-connection [expr]
  sshctl [global-options] -mg|--move-group [expr]
  sshctl [global-options] -mc|--modify-credential [expr]

Global options:
  --config <file>
    - ì„¤ì • íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•©ë‹ˆë‹¤. íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ í•´ë‹¹ íŒŒì¼ì„ ì„¤ì •ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - íŒŒì¼ì´ ì—†ìœ¼ë©´ ê²½ê³  ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³  ê¸°ë³¸ ê²½ë¡œ(${DEFAULT_CONFIG_FILE})ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

  --masterkey <file>
    - 'ë¯¼ê°ì •ë³´'(username, credential) ì•”/ë³µí˜¸í™”ì— ì‚¬ìš©ë  OpenSSH private key ê²½ë¡œë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
    - ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ê°’(${MASTERKEY_DEFAULT})ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

  -s, --show-credential
    - ëª©ë¡/ë¯¸ë¦¬ë³´ê¸°ì—ì„œ credential ê°’ì„ í‰ë¬¸ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    - ê¸°ë³¸ê°’ì€ í•­ìƒ "****************" (16ê°œ ë³„í‘œ)ë¡œ ë§ˆìŠ¤í‚¹í•©ë‹ˆë‹¤.

  -n, --number <N>
    - ë°”ë¡œ ì ‘ì† ê¸°ëŠ¥ì—ì„œ ì‚¬ìš©í•  ë²ˆí˜¸(#)ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
    - ì´ ì˜µì…˜ì€ connect ë™ì‘ì—ì„œë§Œ ìœ íš¨í•˜ë©°, ëª©ë¡ì„ ì¶œë ¥í•˜ì§€ ì•Šê³  Në²ˆì§¸ í•­ëª©ìœ¼ë¡œ ë°”ë¡œ ì ‘ì†í•©ë‹ˆë‹¤.
    - ë‹¤ë¥¸ ëª¨ë“œ ì˜µì…˜(-l/-a/-m/-d/-mg/-mc)ê³¼ëŠ” í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

Commands:
  -l, --list-all [expr]
    - SSH connection ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
    - ê²€ìƒ‰ì‹ expr ì´ ìˆëŠ” ê²½ìš°, expr ì— í•´ë‹¹í•˜ëŠ” connection ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.

  -a, --add-connection
    - ìƒˆë¡œìš´ SSH connection ì •ë³´ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (interactive).
    - auth_type ì´ 'key' ì¸ ê²½ìš°, key path ëŠ” í•­ìƒ "ì ˆëŒ€ê²½ë¡œ"ë¡œ ì €ì¥ë©ë‹ˆë‹¤.
    - auth_type ì´ 'password' ì¸ ê²½ìš°, connection ì €ì¥ í›„ sshpass ê°€ ì—†ìœ¼ë©´ ìë™ ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.

  -m, --modify-connection [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ì„ íƒëœ connection ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
    - ìˆ˜ì • í›„ ê²°ê³¼ connection 1ê±´ì„ í‘œ í˜•íƒœë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.

  -d, --delete-connection [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ì‚­ì œ ëŒ€ìƒ connection 1ê±´ì„ í‘œë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    - ì‚¬ìš©ìê°€ y/yes ë¡œ í™•ì¸í•˜ë©´ ì‹¤ì œë¡œ ì‚­ì œí•©ë‹ˆë‹¤.

  -mg, --move-group [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ connection ì„ ê³ ë¥¸ ë’¤, ê·¸ë£¹(group) ê°’ì„ ë³€ê²½í•©ë‹ˆë‹¤.

  -mc, --modify-credential [expr]
    - ê²€ìƒ‰ì‹ expr ìœ¼ë¡œ password ë°©ì‹ connection ëª©ë¡ì„ ê³ ë¥¸ ë’¤, ë²ˆí˜¸(#)ë¥¼ ì½¤ë§ˆ(,)ë¡œ ì—¬ëŸ¬ ê°œ ì„ íƒí•©ë‹ˆë‹¤.
      - 'credential' ì •ë³´ëŠ” í‰ë¬¸(plain text)ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.
    - ì…ë ¥í•œ ìƒˆ password(credential)ë¥¼ ì„ íƒëœ ì—¬ëŸ¬ connectionì— ì¼ê´„ ì ìš©í•©ë‹ˆë‹¤.
    - ë³€ê²½ëœ connection ëª©ë¡ì„ í‘œ í˜•íƒœë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.

ê¸°ë³¸ ì ‘ì† ë™ì‘:
  1) sshctl
     - ì „ì²´ connection ëª©ë¡ì—ì„œ ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•´ ì ‘ì†í•©ë‹ˆë‹¤.

  2) sshctl <expr>
     - (ì„ íƒ) -n|--number <N> ì„ í•¨ê»˜ ì£¼ë©´, ëª©ë¡ì„ ë³´ì—¬ì£¼ì§€ ì•Šê³  Në²ˆì§¸ í•­ëª©ìœ¼ë¡œ ë°”ë¡œ ì ‘ì†í•©ë‹ˆë‹¤.
       ì˜ˆ: sshctl mycom -n 2 / sshctl -n 2 mycom

     - <expr> ì´ "-" ë¡œ ì‹œì‘í•˜ëŠ” ì˜µì…˜ì´ ì•„ë‹ˆë©´ ê²€ìƒ‰ì‹ìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
     - expr ìœ¼ë¡œ í•„í„°ë§ í›„, ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•´ ì ‘ì†í•©ë‹ˆë‹¤.
     - auth_type ì´ password ì¸ ê²½ìš°, sshpass ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì–´ì•¼ í•˜ë©°,
       ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ì´ë²ˆ ì ‘ì†ì€ ì·¨ì†Œí•˜ê³  sshpass ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.

ê²€ìƒ‰ì‹ (Search expression) ì˜ˆ:
  {dev} or {%prod%} and {web}
  - {í‚¤ì›Œë“œ} : group/name/host ì— í‚¤ì›Œë“œê°€ í¬í•¨ëœ í•­ëª©
  - %ë¬¸ìì—´% : ë¬¸ìì—´ì„ í¬í•¨í•˜ëŠ” í•­ëª©
  - ë¬¸ìì—´%  : í•´ë‹¹ ë¬¸ìì—´ë¡œ ì‹œì‘í•˜ëŠ” í•­ëª©
  - %ë¬¸ìì—´  : í•´ë‹¹ ë¬¸ìì—´ë¡œ ëë‚˜ëŠ” í•­ëª©
  - and / or : ì¡°ê±´ ê²°í•© (ì¤‘ì²© ì¤‘ê´„í˜¸ í˜•íƒœë„ ì§€ì›)

ì •ë ¬ ê·œì¹™ (Sort rule):
  1) group == "default" ì¸ í•­ëª©ì´ í•­ìƒ ìµœìƒìœ„
  2) ê·¸ ì™¸ group ì€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
  3) ê°™ì€ group ë‚´ì—ì„œëŠ” name ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

ì»¬ëŸ¼ ìˆœì„œ (Column order):
  #, Group, Name, Host, Port, User, Credential(í‘œì‹œ ì‹œ ë§ˆìŠ¤í‚¹ ë˜ëŠ” í‰ë¬¸)
EOF
}

# =======================================
# Common utils
# =======================================

##
# ë¡œê·¸ë¥¼ stderrë¡œ ì¶œë ¥í•œë‹¤. í¬ë§·ì€ [LEVEL] message í˜•íƒœì´ë‹¤.
# Print log messages to stderr in the form of [LEVEL] message.
#
# @param $1 {string} ë¡œê·¸ ë ˆë²¨ (ì˜ˆ: INFO, WARN, ERROR) / log level (e.g. INFO, WARN, ERROR)
# @param $2..$n {string} ì¶œë ¥í•  ë©”ì‹œì§€ ì¡°ê°ë“¤ / message tokens to be printed
#
# @return {int} í•­ìƒ 0 (í‘œì¤€ì—ëŸ¬ë¡œë§Œ ì¶œë ¥) / always 0 (only writes to stderr)
##
log() {
  local level="$1"
  shift
  printf '[%s] %s\n' "${level}" "$*" >&2
}

##
# ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ help()ë¥¼ í†µí•´ ì¶œë ¥í•˜ê³  ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¢…ë£Œí•œë‹¤.
# Print an error message via help() and terminate the script.
#
# @param $1..$n {string} ì—ëŸ¬ ë©”ì‹œì§€ ì „ì²´ (ê³µë°± í¬í•¨) / full error message (can include spaces)
#
# @return {int} exit 1ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¦‰ì‹œ ì¢…ë£Œ / terminates the process with exit code 1
##
die() {
  local msg="$*"
  local line="${BASH_LINENO[0]:-0}"
  help "$msg" "$line"
  exit 1
}

##
# ì„¤ì • ë””ë ‰í† ë¦¬ì™€ ì„¤ì • íŒŒì¼ì„ ë³´ì¥í•˜ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ JSON êµ¬ì¡°ë¡œ ìƒì„±í•œë‹¤.
# Ensure the configuration directory/file exist; create with default JSON if missing.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„±ê³µ ì‹œ 0, ë””ë ‰í† ë¦¬/íŒŒì¼ ìƒì„± ì‹¤íŒ¨ ì‹œ ë¹„-0 ê°€ëŠ¥
#         0 on success, non-zero on directory/file creation failure.
##
ensure_config_file() {
  # CONFIG_FILE ê¸°ì¤€ìœ¼ë¡œ CONFIG_DIR ì¬ê³„ì‚°
  CONFIG_DIR="$(dirname "${CONFIG_FILE}")"

  if [[ ! -d "${CONFIG_DIR}" ]]; then
    mkdir -p "${CONFIG_DIR}"
  fi

  # masterkey íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ md5 ê³„ì‚°
  local masterkey_md5=""
  if [[ -f "${MASTERKEY_FILE}" ]]; then
    masterkey_md5="$(md5sum "${MASTERKEY_FILE}" | awk '{print $1}')"
  fi

  if [[ ! -f "${CONFIG_FILE}" ]]; then
    # ìƒˆ configuration íŒŒì¼ ìƒì„± ì‹œ masterkey_md5 í¬í•¨
    cat > "${CONFIG_FILE}" <<EOF
{
  "version": "${CONFIG_VERSION}",
  "masterkey_md5": "${masterkey_md5}",
  "connections": []
}
EOF
    chmod 600 "${CONFIG_FILE}"
  else
    chmod 600 "${CONFIG_FILE}" || true
  fi
}

##
# jq, ssh ë“±ì˜ í•„ìˆ˜ ì˜ì¡´ì„±ì„ ì ê²€í•˜ê³ , ëˆ„ë½ëœ ê²½ìš° ìë™ ì„¤ì¹˜ í›„ ì•ˆë‚´í•˜ê³  ì¢…ë£Œí•œë‹¤.
# Check required dependencies (jq, ssh, md5sum); install missing ones in one shot, notify, and exit.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ëª¨ë“  ì˜ì¡´ì„±ì´ ì¡´ì¬í•˜ë©´ 0
#         If dependencies were installed successfully, prints a message and exits 0 (user should rerun).
#         ì„¤ì¹˜ ì‹¤íŒ¨/ê¶Œí•œ ë¶€ì¡±/ì§€ì›ë˜ì§€ ì•ŠëŠ” í™˜ê²½ì´ë©´ die() ë¡œ ì¢…ë£Œ (ë¹„-0)
#         Terminates via die() (non-zero) on failure/privilege issue/unsupported environment.
##
ensure_dependencies() {
  local missing_cmds=()
  local pkgs=()

  # ---------------------------------------
  # helpers (local)
  # ---------------------------------------
  _add_unique() {
    local arr_name="$1"
    local val="$2"
    local x
    eval "for x in \"\${${arr_name}[@]-}\"; do
      if [[ \"\${x}\" == \"\${val}\" ]]; then
        return 0
      fi
    done"
    eval "${arr_name}+=(\"\${val}\")"
  }

  _progress_line() {
    # í•œ ì¤„ ì§„í–‰ í‘œì‹œ / One-line progress display.
    # - \r: line rewind, \033[K: clear to end of line
    printf '\r%s\033[K' "$1"
  }

  _progress_done() {
    printf '\r%s\033[K\n' "$1"
  }

  _run_quiet_or_die() {
    # ì¶œë ¥ ì–µì œ + ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ì¶œë ¥ / Suppress output; show logs on failure.
    # @param $1 {string} label
    # @param $2... command
    local label="$1"
    shift

    local tmp_out
    tmp_out="$(mktemp -t sshctl-dep.XXXXXX)"
    _progress_line "â³ ${label} ..."
    if ! "$@" >"${tmp_out}" 2>&1; then
      _progress_done "âŒ ${label} ì‹¤íŒ¨"
      echo "---- command output (begin) ----" >&2
      cat "${tmp_out}" >&2
      echo "---- command output (end) ----" >&2
      rm -f "${tmp_out}"
      die "${label} failed."
    fi
    rm -f "${tmp_out}"
    _progress_done "âœ… ${label} ì™„ë£Œ"
  }

  # ---------------------------------------
  # 1) detect package manager
  # ---------------------------------------
  local is_deb=false
  local is_rpm=false

  if command -v apt-get >/dev/null 2>&1; then
    is_deb=true
  fi
  if command -v dnf >/dev/null 2>&1 || command -v yum >/dev/null 2>&1; then
    is_rpm=true
  fi

  # ---------------------------------------
  # 2) check all required commands first
  # ---------------------------------------
  if ! command -v jq >/dev/null 2>&1; then
    missing_cmds+=( "jq" )
    _add_unique pkgs "jq"
  fi

  if ! command -v ssh >/dev/null 2>&1; then
    missing_cmds+=( "ssh" )
    if ${is_deb}; then
      _add_unique pkgs "openssh-client"
    else
      _add_unique pkgs "openssh-clients"
    fi
  fi

  if ! command -v md5sum >/dev/null 2>&1; then
    missing_cmds+=( "md5sum" )
    # md5sum is usually in coreutils (RHEL/Ubuntu). / ëŒ€ë¶€ë¶„ coreutils
    _add_unique pkgs "coreutils"
  fi

  # nothing missing
  if [[ "${#missing_cmds[@]}" -eq 0 ]]; then
    return 0
  fi

  # ---------------------------------------
  # 3) prepare privilege runner (sudo/root)
  # ---------------------------------------
  local runner_cmd=()
  if [[ "$(id -u)" -ne 0 ]]; then
    if command -v sudo >/dev/null 2>&1; then
      runner_cmd=(sudo)
      echo "============================================================================"
      echo "â— sshctl ì‹¤í–‰ì— í•„ìš”í•œ ì˜ì¡´ì„± ë„êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤. ìë™ ì„¤ì¹˜ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤."
      echo "â— Missing required tools for sshctl. Installing required packages."
      echo
      echo "âš ï¸  ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ê³§ sudo ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì„ ìš”ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
      echo "âš ï¸  Root privilege is required. sudo may prompt for your password."
      echo "============================================================================"
      echo
    else
      die "Missing dependencies (${missing_cmds[*]}). Need root or sudo to install: ${pkgs[*]}"
    fi
  else
    echo "============================================================================"
    echo "â— sshctl ì‹¤í–‰ì— í•„ìš”í•œ ì˜ì¡´ì„± ë„êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤. ìë™ ì„¤ì¹˜ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤."
    echo "â— Missing required tools for sshctl. Installing required packages."
    echo "============================================================================"
    echo
  fi

  printf 'âš™ï¸  missing commands: %s\n' "${missing_cmds[*]}"
  printf 'âš™ï¸  install packages: %s\n' "${pkgs[*]}"
  echo

  # ---------------------------------------
  # 4) install missing packages in one shot
  #    - apt-get update output suppression/standardization applied
  # ---------------------------------------
  if ${is_deb}; then
    # apt-get update: suppress output, standardize options
    # -qq: less output, Use-Pty=0: avoid interactive progress noise
    _run_quiet_or_die "apt-get update" \
      "${runner_cmd[@]}" apt-get -o Dpkg::Use-Pty=0 update -qq

    # apt-get install: suppress output, noninteractive, one shot
    _run_quiet_or_die "apt-get install (${pkgs[*]})" \
      env DEBIAN_FRONTEND=noninteractive \
      "${runner_cmd[@]}" apt-get -o Dpkg::Use-Pty=0 install -y -qq --no-install-recommends "${pkgs[@]}"

  elif command -v dnf >/dev/null 2>&1; then
    _run_quiet_or_die "dnf install (${pkgs[*]})" \
      "${runner_cmd[@]}" dnf -y -q install "${pkgs[@]}"

  elif command -v yum >/dev/null 2>&1; then
    _run_quiet_or_die "yum install (${pkgs[*]})" \
      "${runner_cmd[@]}" yum -y -q install "${pkgs[@]}"

  else
    die "Cannot install dependencies automatically: unsupported package manager. Missing: ${missing_cmds[*]}"
  fi

  # ---------------------------------------
  # 5) re-check after install
  # ---------------------------------------
  local still_missing=()
  if ! command -v jq >/dev/null 2>&1; then
    still_missing+=( "jq" )
  fi
  if ! command -v ssh >/dev/null 2>&1; then
    still_missing+=( "ssh" )
  fi
  if ! command -v md5sum >/dev/null 2>&1; then
    still_missing+=( "md5sum" )
  fi

  if [[ "${#still_missing[@]}" -gt 0 ]]; then
    die "Dependency installation completed but some commands are still missing: ${still_missing[*]}"
  fi

  # ---------------------------------------
  # 6) notify and exit (user should rerun)
  # ---------------------------------------
  echo
  echo "âœ… 'sshctl' í”„ë¡œê·¸ë¨ì— í•„ìš”í•œ ë„êµ¬ë¥¼ ëª¨ë‘ ì„¤ì¹˜í•˜ì˜€ìŠµë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì‹¤í–‰ì‹œì¼œ ì£¼ì„¸ìš”."
  echo "âœ… Installed all required tools for 'sshctl'. Please rerun the program."
  echo
  exit 0
}

##
# configuration.masterkey_md5 ì™€ ì‹¤ì œ MASTERKEY_FILE md5 ë¥¼ ë¹„êµí•´ ì •í•©ì„±ì„ ê²€ì¦í•œë‹¤.
# MASTERKEY_FILE ì´ ì—†ìœ¼ë©´ OpenSSH private key ë¥¼ ìƒì„±í•˜ê³ , í•„ìš”í•œ ê²½ìš° ì‚¬ìš©ìì—ê²Œ
# ìƒˆë¡œìš´ masterkey ê²½ë¡œë¥¼ ì…ë ¥ë°›ì•„ configuration ê³¼ì˜ ì •í•©ì„±ì„ ë§ì¶˜ë‹¤.
# Verify consistency between configuration.masterkey_md5 and actual MASTERKEY_FILE md5.
# If MASTERKEY_FILE does not exist, create an OpenSSH private key, and if necessary,
# interactively ask the user for a new masterkey path until it matches configuration.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„±ê³µ ì‹œ 0, ì‚¬ìš©ì ì·¨ì†Œ ë˜ëŠ” ë³µêµ¬ ë¶ˆê°€ ì‹œ die() ë¥¼ í†µí•´ ì¢…ë£Œ
#         0 on success; terminates via die() when user cancels or mismatch cannot be resolved.
##
ensure_masterkey_md5() {
  # 1) MASTERKEY_FILE ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ OpenSSH private key ìƒì„±
  # 1) If MASTERKEY_FILE does not exist, create an OpenSSH private key.
  if [[ ! -f "${MASTERKEY_FILE}" ]]; then
    local key_dir
    key_dir="$(dirname "${MASTERKEY_FILE}")"

    if [[ ! -d "${key_dir}" ]]; then
      mkdir -p "${key_dir}"
    fi

    echo
    echo "â— masterkey(OpenSSH private key) íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "â— ìƒˆë¡œìš´ masterkey íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤."
    echo "â“ ssh-keygen ì‹¤í–‰ ì¤‘ì— í‘œì‹œë˜ëŠ” í”„ë¡¬í”„íŠ¸ì— ë”°ë¼ ë¹„ë°€ë²ˆí˜¸(passphrase)ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
    echo "ğŸ”‘ target: ${MASTERKEY_FILE}"
    echo

    # ì‚¬ìš©ìê°€ ì§ì ‘ passphrase ë¥¼ ì…ë ¥í•˜ë„ë¡ ssh-keygen ì„ ê·¸ëŒ€ë¡œ ì‹¤í–‰
    # Run ssh-keygen as-is so the user can provide a passphrase interactively.
    if ! ssh-keygen -t ed25519 -f "${MASTERKEY_FILE}"; then
      die "masterkey(OpenSSH private key) ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ssh-keygen ì‹¤íŒ¨)"
    fi

    if [[ ! -f "${MASTERKEY_FILE}" ]]; then
      die "masterkey(OpenSSH private key) íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: ${MASTERKEY_FILE}"
    fi

    # *.pub íŒŒì¼ ì‚­ì œ
    shred -u "${MASTERKEY_FILE}.pub"
  fi

  # 2) configuration íŒŒì¼ì´ ì—†ìœ¼ë©´ ìƒì„±
  # 2) If configuration file does not exist, create it first.
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    ensure_config_file
  fi

  # 3) MASTERKEY_FILE md5 ê³„ì‚°
  # 3) Calculate md5 of MASTERKEY_FILE.
  local file_md5
  file_md5="$(md5sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # 4) configuration ì•ˆì˜ masterkey_md5 ì½ê¸° (ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´)
  # 4) Read masterkey_md5 from configuration (empty if missing).
  local config_md5
  config_md5="$(jq -r '.masterkey_md5 // ""' "${CONFIG_FILE}" 2>/dev/null || echo "")"

  # 5) configuration.masterkey_md5 ê°€ ì—†ê±°ë‚˜ ë¹„ì–´ ìˆìœ¼ë©´ í˜„ì¬ md5 ë¡œ ì„¤ì •
  # 5) If configuration.masterkey_md5 is missing/empty, set it to current md5.
  if [[ -z "${config_md5}" || "${config_md5}" == "null" ]]; then
    local tmp
    tmp="$(mktemp "${CONFIG_FILE}.XXXXXX")"
    jq --arg md5 "${file_md5}" '.masterkey_md5 = $md5' "${CONFIG_FILE}" > "${tmp}"
    mv "${tmp}" "${CONFIG_FILE}"
    chmod 600 "${CONFIG_FILE}" || true
    return 0
  fi

  # 6) ê°’ì´ ë™ì¼í•˜ë©´ ì •ìƒ ì§„í–‰
  # 6) If md5 values are equal, everything is consistent.
  if [[ "${config_md5}" == "${file_md5}" ]]; then
    return 0
  fi

  # 7) ê°’ì´ ë‹¤ë¥´ë©´ ì‚¬ìš©ìì—ê²Œ ìƒˆë¡œìš´ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥ë°›ì•„ ì¬ê²€ì¦
  # 7) If md5 values differ, ask the user for a new masterkey path and re-validate.
  local current_path="${MASTERKEY_FILE}"
  local current_md5="${file_md5}"

  while true; do
    local line
    line="============================================================================"

    echo "${line}"
    printf 'âš™ï¸  masterkey_file              : %s\n' "${current_path}"
    printf 'âš™ï¸  masterkey_file.md5          : %s\n' "${current_md5}"
    printf 'âš™ï¸  configuration.masterkey_md5 : %s\n' "${config_md5}"
    echo "${line}"
    echo
    echo "â— MASTERKEY_FILE ê³¼ configuration.masterkey_md5 ê°’ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
    echo "â— configuration ì— ì €ì¥ëœ masterkey_md5 ì™€ ë™ì¼í•œ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
    echo 
    echo "   (ì…ë ¥ì„ ë¹„ìš°ê³  Enter ë¥¼ ëˆ„ë¥´ë©´ ì‘ì—…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.)"
    echo

    printf "ìƒˆ masterkey íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš”: "
    local new_path
    IFS= read -er new_path || {
      die "masterkey ê²€ì¦ ì¤‘ ì…ë ¥ì„ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    }

    # ì‚¬ìš©ìê°€ ë¹ˆ ë¬¸ìì—´ì„ ì…ë ¥í•˜ë©´ ì·¨ì†Œë¡œ ê°„ì£¼
    # Treat empty input as user cancellation.
    if [[ -z "${new_path}" ]]; then
      die "masterkey ê²€ì¦ì´ ì‚¬ìš©ìì— ì˜í•´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
    fi

    # ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€ ê²€ì¦
    # Verify that the given path exists.
    local abs_new_path=$(resolve_path_abs "${new_path}")
    if [[ ! -f "${abs_new_path}" ]]; then
      echo "â— ì§€ì •í•œ masterkey íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${abs_new_path}" >&2
      echo 
      echo "   ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
      echo
      continue
    fi

    # ìƒˆ íŒŒì¼ì˜ md5 ê³„ì‚°
    local new_md5
    new_md5="$(md5sum "${abs_new_path}" | awk '{print $1}')"

    if [[ "${new_md5}" == "${config_md5}" ]]; then
      # ì¼ì¹˜í•˜ë©´ MASTERKEY_FILE ì„ ìƒˆ ê²½ë¡œë¡œ ê°±ì‹ í•˜ê³  ì •ìƒ ì¢…ë£Œ
      # On match, update MASTERKEY_FILE and return success.
      MASTERKEY_FILE="${abs_new_path}"
      return 0
    fi

    # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ í˜„ì¬ ê°’ ê°±ì‹  í›„ ë£¨í”„ ë°˜ë³µ
    # If mismatched, update current values and loop.
    current_path="${abs_new_path}"
    current_md5="${new_md5}"
  done
}

##
# ì…ë ¥ëœ í‰ë¬¸(ë¯¼ê°ì •ë³´: username, credential)ì„ AES-256-CBC ë°©ì‹ìœ¼ë¡œ ì•”í˜¸í™”í•œë‹¤.
# Encrypt plaintext (username, credential) using AES-256-CBC with key derived from MASTERKEY_FILE.
#
# @param $1 {string} plaintext í‰ë¬¸ ë°ì´í„°
#
# @return {string} ENC::<base64_cipher>
##
encrypt_value() {
  local plaintext="$1"

  # ë¹ˆ ë¬¸ìì—´ì€ ì•”í˜¸í™”í•  í•„ìš” ì—†ìŒ
  if [[ -z "$plaintext" ]]; then
    echo ""
    return 0
  fi

  # íŒŒìƒí‚¤ ìƒì„±: SHA-256(masterkey íŒŒì¼ ë‚´ìš©)
  local derived_key
  derived_key="$(sha256sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # AES-256-CBC ì•”í˜¸í™” (base64 ì¶œë ¥)
  local cipher
  # Base64 ë‹¨ì¼ ë¼ì¸ ê°•ì œ
  cipher="$(echo -n "$plaintext" \
      | openssl enc -aes-256-cbc -a -A -salt -pass pass:"$derived_key" 2>/dev/null)"

  if [[ $? -ne 0 || -z "$cipher" ]]; then
    die "ë¯¼ê°ì •ë³´ ì•”í˜¸í™”(encrypt_value) ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
  fi

  echo "ENC::${cipher}"
}

##
# ì…ë ¥ëœ ê°’ì´ ENC:: ë¡œ ì‹œì‘í•˜ë©´ ë³µí˜¸í™”í•˜ì—¬ í‰ë¬¸ì„ ë°˜í™˜í•œë‹¤.
# If value starts with ENC::, decrypt it using AES-256-CBC with derived key.
#
# @param $1 {string} value ì•”í˜¸ë¬¸ ë˜ëŠ” í‰ë¬¸
#
# @return {string} í‰ë¬¸ ë°ì´í„°
##
decrypt_value_if_needed() {
  local value="$1"

  # ì•”í˜¸ë¬¸ì´ ì•„ë‹ˆë¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if [[ "$value" != ENC::* ]]; then
    echo "$value"
    return 0
  fi

  # cipher ë¶€ë¶„ë§Œ ì¶”ì¶œ
  local cipher="${value#ENC::}"

  # íŒŒìƒí‚¤ ìƒì„±
  local derived_key
  derived_key="$(sha256sum "${MASTERKEY_FILE}" | awk '{print $1}')"

  # ë³µí˜¸í™”
  local plaintext
  plaintext="$(echo "$cipher" \
      | openssl enc -aes-256-cbc -a -d -salt -pass pass:"$derived_key" 2>/dev/null)"

  if [[ $? -ne 0 ]]; then
    die "ë¯¼ê°ì •ë³´ ë³µí˜¸í™”(decrypt_value_if_needed) ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
  fi

  echo "$plaintext"
}

##
# STDINìœ¼ë¡œ ì „ë‹¬ëœ JSONì„ ì„ì‹œ íŒŒì¼ì„ ì‚¬ìš©í•´ CONFIG_FILEì— ì•ˆì „í•˜ê²Œ ì €ì¥í•œë‹¤.
# Safely save JSON from STDIN into CONFIG_FILE using a temporary file.
#
# @param $1 ì—†ìŒ (ì…ë ¥ì€ STDINìœ¼ë¡œ ì „ë‹¬) / none (input JSON is read from STDIN)
#
# @return {int} ì„±ê³µ ì‹œ 0, íŒŒì¼ ì“°ê¸°/ì´ë™ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on write/move failures.
##
save_connections_json() {
  local tmp
  tmp="$(mktemp "${CONFIG_FILE}.XXXXXX")"
  cat > "${tmp}"
  mv "${tmp}" "${CONFIG_FILE}"
  chmod 600 "${CONFIG_FILE}"
}

##
# ~, ìƒëŒ€ê²½ë¡œ ë“±ì„ í¬í•¨í•œ ê²½ë¡œë¥¼ ì ˆëŒ€ê²½ë¡œë¡œ ì •ê·œí™”í•œë‹¤.
# Normalize a given path (including ~ and relative paths) into an absolute path.
#
# @param $1 {string} ì›ë³¸ ê²½ë¡œ (ìƒëŒ€/ì ˆëŒ€/tilde í¬í•¨ ê°€ëŠ¥) / original path (relative/absolute/tilde)
#
# @return {string} STDOUTë¡œ ì ˆëŒ€ê²½ë¡œë¥¼ ì¶œë ¥ / prints the absolute path to STDOUT
# @return {int} í•­ìƒ 0 (readlink ì˜¤ë¥˜ ì‹œ ì›ë˜ ê²½ë¡œ ê¸°ì¤€) / always 0; falls back when readlink fails.
##
resolve_path_abs() {
  local p="$1"

  if [[ -z "$p" ]]; then
    printf '%s\n' ""
    return 0
  fi

  if [[ "$p" == ~* ]]; then
    p="${p/#\~/$HOME}"
  fi

  if [[ "$p" != /* ]]; then
    p="${PWD}/${p}"
  fi

  if command -v readlink >/dev/null 2>&1; then
    local r
    if r=$(readlink -f -- "$p" 2>/dev/null); then
      p="$r"
    fi
  fi

  printf '%s\n' "$p"
}

##
# SHOW_CREDENTIAL í”Œë˜ê·¸ì— ë”°ë¼ credential ì¶œë ¥ê°’ì„ ê²°ì •í•œë‹¤.
# Decide how to display credential value depending on SHOW_CREDENTIAL flag.
#
# @param $1 {string} cred ì‹¤ì œ credential ê°’ / actual credential value
#
# @return {string} STDOUTë¡œ í‘œì‹œìš© credential ì¶œë ¥ / prints displayable credential to STDOUT.
# @return {int} í•­ìƒ 0 / always 0.
##
format_credential_for_display() {
  local cred="$1"

  case "$EXEC_CMD" in
    # [ì—°ê²°ì •ë³´ ëª©ë¡] (-l | --list-all)
    # [ì—°ê²°ì •ë³´ ìˆ˜ì •] (-m | --modify-connection)
    # - ê¸°ë³¸: masking list (****************)
    # - -s / --show-credential ì´ ìˆëŠ” ê²½ìš°: plain list
    list | modify)
      if [[ "$SHOW_CREDENTIAL" == "true" ]]; then
        printf '%s' "$cred"
      else
        printf '****************'
      fi
      ;;

    # [ì—°ê²°ì •ë³´ ì¶”ê°€] (-a | --add-connection)
    # - ê¸°ë³¸: masking list
    # - -s / --show-credential ì´ ìˆëŠ” ê²½ìš°: ë¯¸ë¦¬ë³´ê¸°ì—ì„œë§Œ plain
    add)
      if [[ "$SHOW_CREDENTIAL" == "true" ]]; then
        printf '%s' "$cred"
      else
        printf '****************'
      fi
      ;;

    # [ë¹„ë°€ë²ˆí˜¸ ì¼ê´„ë³€ê²½] (-mc | --modify-credential)
    # - ê¸°ë³¸: "plain list"
    modify-credential)
      printf '%s' "$cred"
      ;;

    # [ì„œë²„ ì ‘ì†], [ì—°ê²°ì •ë³´ ì‚­ì œ], [ì—°ê²°ì •ë³´ ê·¸ë£¹ì´ë™]
    # - ìš”êµ¬ì‚¬í•­: í•­ìƒ "masking list"
    # - --show-credential ì˜µì…˜ ì§€ì›í•˜ì§€ ì•ŠìŒ â†’ í•­ìƒ ë§ˆìŠ¤í‚¹
    connect|delete|move-group)
      printf '****************'
      ;;

    # ê·¸ ì™¸ (ì•ˆì „í•˜ê²Œ ê¸°ë³¸ì€ ë§ˆìŠ¤í‚¹)
    *)
      printf '****************'
      ;;
  esac
}

##
# sshpass ê°€ ì—†ì„ ê²½ìš° ì‹œìŠ¤í…œ íŒ¨í‚¤ì§€ ê´€ë¦¬ì(apt, yum/dnf, zypper, apk ë“±)ë¥¼ ì‚¬ìš©í•´ ì„¤ì¹˜ë¥¼ ì‹œë„í•œë‹¤.
# Try to install sshpass using system package manager (apt, yum/dnf, zypper, apk, etc.) if not present.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} ì„¤ì¹˜ í›„ sshpass ê°€ ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ 0, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 1
#         0 if sshpass becomes available after installation; 1 otherwise.
##
install_sshpass_if_missing() {
  if command -v sshpass >/dev/null 2>&1; then
    return 0
  fi

  log INFO "sshpass not found. Trying to install..."

  local pm=""
  if command -v apt-get >/dev/null 2>&1; then
    pm="apt"
  elif command -v dnf >/dev/null 2>&1; then
    pm="dnf"
  elif command -v yum >/dev/null 2>&1; then
    pm="yum"
  elif command -v zypper >/dev/null 2>&1; then
    pm="zypper"
  elif command -v apk >/dev/null 2>&1; then
    pm="apk"
  fi

  case "$pm" in
    apt)
      if sudo apt-get update && sudo apt-get install -y sshpass; then
        log INFO "sshpass installed via apt."
      fi
      ;;
    dnf)
      if sudo dnf install -y sshpass; then
        log INFO "sshpass installed via dnf."
      fi
      ;;
    yum)
      if sudo yum install -y sshpass; then
        log INFO "sshpass installed via yum."
      fi
      ;;
    zypper)
      if sudo zypper install -y sshpass; then
        log INFO "sshpass installed via zypper."
      fi
      ;;
    apk)
      if sudo apk add sshpass; then
        log INFO "sshpass installed via apk."
      fi
      ;;
    *)
      log WARN "Unsupported package manager. Please install sshpass manually."
      ;;
  esac

  if command -v sshpass >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

# =======================================
# Validation helpers
# =======================================

##
# ê°’ì´ ë¹„ì–´ ìˆì§€ ì•Šì€ì§€ ê²€ì‚¬í•œë‹¤. ë¹„ì–´ ìˆìœ¼ë©´ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.
# Validate that a given value is not empty; prints an error message if it is empty.
#
# @param $1 {string} í•„ë“œ ë ˆì´ë¸” (ì˜ˆ: group, name) / field label (e.g. group, name)
# @param $2 {string} ì‹¤ì œ ê°’ / actual value
#
# @return {int} ë¹„ì–´ ìˆì§€ ì•Šìœ¼ë©´ 0, ë¹„ì–´ ìˆìœ¼ë©´ 1
#         0 if non-empty; 1 if empty.
##
validate_non_empty() {
  local label="$1"
  local value="$2"
  if [[ -z "$value" ]]; then
    printf 'ì…ë ¥ ì˜¤ë¥˜: %s ì€(ëŠ”) ë¹„ì–´ ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n' "$label" >&2
    return 1
  fi
  return 0
}

##
# host_type ê°’ì´ ipv4|ipv6|domain ì¤‘ í•˜ë‚˜ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that host_type is one of ipv4, ipv6, or domain.
#
# @param $1 {string} host_type ê°’ / host_type value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_host_type() {
  local value="$1"
  case "$value" in
    ipv4|ipv6|domain)
      return 0
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: host_type ì€ ipv4|ipv6|domain ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
      return 1
      ;;
  esac
}

##
# auth_type ê°’ì´ password|key ì¤‘ í•˜ë‚˜ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that auth_type is either password or key.
#
# @param $1 {string} auth_type ê°’ / auth_type value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_auth_type() {
  local value="$1"
  case "$value" in
    password|key)
      return 0
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: auth_type ì€ password|key ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
      return 1
      ;;
  esac
}

##
# port ê°’ì´ ìˆ«ìì´ê³  1~65535 ë²”ìœ„ì¸ì§€ í™•ì¸í•œë‹¤.
# Validate that port is numeric and in the range 1â€“65535.
#
# @param $1 {string} í¬íŠ¸ ë¬¸ìì—´ / port string
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê°’ì´ë©´ 1
#         0 if valid; 1 if invalid.
##
validate_port() {
  local value="$1"
  if ! [[ "$value" =~ ^[0-9]+$ ]]; then
    printf 'ì…ë ¥ ì˜¤ë¥˜: port ëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
    return 1
  fi
  if (( value < 1 || value > 65535 )); then
    printf 'ì…ë ¥ ì˜¤ë¥˜: port ë²”ìœ„ëŠ” 1 ~ 65535 ì…ë‹ˆë‹¤. (í˜„ì¬: %s)\n' "$value" >&2
    return 1
  fi
  return 0
}

##
# host_type ìœ í˜•ì— ë”°ë¼ host í˜•ì‹ì„ ê²€ì¦í•œë‹¤.
# Validate host format based on host_type (ipv4, ipv6, or domain).
#
# @param $1 {string} host_type (ipv4|ipv6|domain)
# @param $2 {string} host ê°’ / host value
#
# @return {int} ìœ íš¨í•˜ë©´ 0, ì˜ëª»ëœ ê²½ìš° 1
#         0 if valid; 1 if invalid.
##
validate_host_by_type() {
  local host_type="$1"
  local host="$2"

  case "$host_type" in
    ipv4)
      if ! [[ "$host" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: ipv4 host í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì˜ˆ: 192.168.0.10)\n' >&2
        return 1
      fi
      ;;
    ipv6)
      if [[ "$host" != *:* ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: ipv6 host ëŠ” ":" ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.\n' >&2
        return 1
      fi
      ;;
    domain)
      if ! [[ "$host" =~ ^[A-Za-z0-9.-]+$ ]]; then
        printf 'ì…ë ¥ ì˜¤ë¥˜: domain host í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì˜ˆ: gitlab.ymtech.co.kr)\n' >&2
        return 1
      fi
      ;;
    *)
      printf 'ì…ë ¥ ì˜¤ë¥˜: ì•Œ ìˆ˜ ì—†ëŠ” host_type ì…ë‹ˆë‹¤: %s\n' "$host_type" >&2
      return 1
      ;;
  esac
  return 0
}

# =======================================
# Prompt label width ì´ˆê¸°í™”
# =======================================

##
# í”„ë¡¬í”„íŠ¸ì—ì„œ ì‚¬ìš©í•  í•„ë“œëª… ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ PROMPT_LABEL_WIDTHë¥¼ ê³„ì‚°í•œë‹¤.
# Compute PROMPT_LABEL_WIDTH based on the maximum length of field labels.
#
# @param $1 ì—†ìŒ / none
#
# @return {int} í•­ìƒ 0, PROMPT_LABEL_WIDTH ì „ì—­ ë³€ìˆ˜ ì„¤ì •
#         Always 0; sets global PROMPT_LABEL_WIDTH.
##
init_prompt_label_width() {
  local labels=(
    "group"
    "name"
    "host_type (ipv4|ipv6|domain)"
    "host"
    "port"
    "username"
    "auth_type (password|key)"
    "password"
    "key path"
    "ìƒˆ group"
  )
  local max=0 len
  for f in "${labels[@]}"; do
    len=${#f}
    if (( len > max )); then
      max=$len
    fi
  done
  # ì•„ì´ì½˜(2ì¹¸ ê°€ì •) + ê³µë°± 2ì¹¸ + í•„ë“œëª… + ì—¬ìœ  2ì¹¸
  PROMPT_LABEL_WIDTH=$((max + 6))
}

# =======================================
# Search expression â†’ jq filter
# =======================================

##
# ë‹¨ì¼ í‚¤ì›Œë“œ(ì™€ì¼ë“œì¹´ë“œ % í¬í•¨)ë¥¼ ì´ìš©í•´ group/name/hostì— ëŒ€í•œ jq ì¡°ê±´ì‹ì„ ìƒì„±í•œë‹¤.
# Build a jq condition for a single keyword (with % wildcards) over group/name/host.
#
# @param $1 {string} ê²€ìƒ‰ í‚¤ì›Œë“œ (ì˜ˆ: git, g%, %lab, %prod%) / search keyword with optional % wildcards
#
# @return {string} STDOUTë¡œ jq boolean í‘œí˜„ì‹ ì¶œë ¥ / prints jq boolean expression to STDOUT
# @return {int} 0 (ì •ìƒ) / 0 on success.
##
build_single_condition() {
  local kw="$1"
  local mode="contains"
  local core="$kw"

  if [[ "$core" == %*% ]]; then
    core="${core#%}"
    core="${core%%%}"
    mode="contains"
  elif [[ "$core" == *% ]]; then
    core="${core%%%}"
    mode="starts"
  elif [[ "$core" == %* ]]; then
    core="${core#%}"
    mode="ends"
  else
    mode="contains"
  fi

  local core_l="${core,,}"

  local esc
  esc="$(printf '%s' "$core_l" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"

  local field_expr_group='.group // "" | ascii_downcase'
  local field_expr_name='.name // "" | ascii_downcase'
  local field_expr_host='.host // "" | ascii_downcase'

  local cmp_func=""
  case "$mode" in
    contains)
      cmp_func="contains(\"$esc\")"
      ;;
    starts)
      cmp_func="startswith(\"$esc\")"
      ;;
    ends)
      cmp_func="endswith(\"$esc\")"
      ;;
    *)
      cmp_func="contains(\"$esc\")"
      ;;
  esac

  printf '((%s | %s) or (%s | %s) or (%s | %s))' \
    "$field_expr_group" "$cmp_func" \
    "$field_expr_name"  "$cmp_func" \
    "$field_expr_host"  "$cmp_func"
}

##
# ì „ì²´ ê²€ìƒ‰ì‹(expr)ì„ íŒŒì‹±í•˜ì—¬ AND/OR ì¡°í•© jq filter í‘œí˜„ì‹ìœ¼ë¡œ ë³€í™˜í•œë‹¤.
# Parse a whole search expression and convert it into a jq filter with AND/OR conditions.
#
# @param $1 {string} ê²€ìƒ‰ì‹ ë¬¸ìì—´ (ì˜ˆ: {dev} or {%prod%} and {web}) / raw search expression string
#
# @return {string} STDOUTë¡œ ì™„ì„±ëœ jq filter ë¬¸ìì—´ ì¶œë ¥ / prints final jq filter string to STDOUT
# @return {int} 0 (ì •ìƒ), ê²€ìƒ‰ì‹ì´ ë¹„ì–´ ìˆìœ¼ë©´ "true" ì¶œë ¥
#         0 on success; prints "true" for empty expressions.
##
build_search_filter() {
  local expr="$1"

  # ì–‘ìª½ ê³µë°± ì œê±°
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  # ë¹ˆ expr ì´ë©´ ì „ì²´(true)
  if [[ -z "$expr" ]]; then
    echo "true"
    return 0
  fi

  _build_search_filter_inner "$expr"
}

# ë‚´ë¶€ ì¬ê·€ íŒŒì„œ
_build_search_filter_inner() {
  local expr="$1"

  # ì†Œë¬¸ì + ê³µë°± ì •ê·œí™”
  expr="${expr,,}"
  expr="$(printf '%s' "$expr" | tr -s '[:space:]' ' ')"
  expr="${expr#"${expr%%[![:space:]]*}"}"
  expr="${expr%"${expr##*[![:space:]]}"}"

  local conds=()
  local ops=()
  local rest="$expr"

  while [[ -n "$rest" ]]; do
    # ì•ìª½ ê³µë°± ì œê±°
    rest="${rest#"${rest%%[![:space:]]*}"}"
    [[ -z "$rest" ]] && break

    if [[ "${rest:0:1}" == "{" ]]; then
      # ì¤‘ì²© { } ì²˜ë¦¬ìš© brace depth
      local depth=0
      local len=${#rest}
      local i
      for ((i=0; i<len; i++)); do
        local ch="${rest:i:1}"
        if [[ "$ch" == "{" ]]; then
          depth=$((depth+1))
        elif [[ "$ch" == "}" ]]; then
          depth=$((depth-1))
          if (( depth == 0 )); then
            break
          fi
        fi
      done

      # ì¤‘ê´„í˜¸ ë¶ˆì¼ì¹˜ â†’ ì „ì²´ë¥¼ ë‹¨ì¼ í‚¤ì›Œë“œë¡œ ì²˜ë¦¬
      if (( depth != 0 )); then
        conds=( "$(build_single_condition "$expr")" )
        break
      fi

      local close_pos="$i"
      local inner_len=$((close_pos - 1))
      local inside="${rest:1:inner_len}"   # ê°€ì¥ ë°”ê¹¥ { } ì•ˆìª½
      local next_pos=$((close_pos + 1))
      local remaining="${rest:next_pos}"

      if [[ "$inside" == *"{"* ]]; then
        # ë‚´ë¶€ì— ë˜ { ê°€ ìˆìœ¼ë©´, ë‹¤ì‹œ Expr ë¡œ ì¬ê·€ íŒŒì‹±
        local sub_filter
        sub_filter="$(_build_search_filter_inner "$inside")" || return 1
        conds+=( "(${sub_filter})" )
      else
        # ë‹¨ìˆœ í‚¤ì›Œë“œ
        conds+=( "$(build_single_condition "$inside")" )
      fi

      rest="$remaining"
    else
      # ì•ˆì „ì¥ì¹˜: { ë¡œ ì‹œì‘í•˜ì§€ ì•ŠëŠ” í† í°ì€ "ë‹¨ì¼ í‚¤ì›Œë“œ" ì·¨ê¸‰
      local token="${rest%% *}"
      local remaining="${rest#* }"
      if [[ "$token" == "$rest" ]]; then
        remaining=""
      fi
      conds+=( "$(build_single_condition "$token")" )
      rest="$remaining"
    fi

    # op (and|or) íŒŒì‹±
    rest="${rest#"${rest%%[![:space:]]*}"}"
    if [[ "$rest" =~ ^(and|or)[[:space:]]+(.*)$ ]]; then
      ops+=( "${BASH_REMATCH[1]}" )
      rest="${BASH_REMATCH[2]}"
    else
      break
    fi
  done

  # term ì´ í•˜ë‚˜ë„ ì•ˆ ì¡í˜”ìœ¼ë©´ ì „ì²´ expr ì„ ë‹¨ì¼ í‚¤ì›Œë“œë¡œ ì²˜ë¦¬
  if (( ${#conds[@]} == 0 )); then
    printf '%s\n' "$(build_single_condition "$expr")"
    return 0
  fi

  # ì™¼ìª½ë¶€í„° fold: ((t1 op1 t2) op2 t3) ...
  local result="${conds[0]}"
  local i
  for ((i=0; i<${#ops[@]}; i++)); do
    local op="${ops[$i]}"
    local rhs="${conds[$((i+1))]}"
    result="(${result} ${op} ${rhs})"
  done

  printf '%s\n' "$result"
}

# =======================================
# List / selection helpers
# =======================================

##
# ê²€ìƒ‰ì‹ì„ ì´ìš©í•´ connectionsë¥¼ í•„í„°ë§í•˜ê³  íƒ­ êµ¬ë¶„ ì›ì‹œ ë¬¸ìì—´ë¡œ ë°˜í™˜í•œë‹¤.
# Filter connections using a search expression and return tab-separated raw lines.
#
# @param $1 {string} query ê²€ìƒ‰ì‹ (ë¹ˆ ë¬¸ìì—´ì´ë©´ ì „ì²´) / search query; empty for all connections
#
# @return {string} STDOUTë¡œ "group[TAB]name[TAB]host[TAB]port[TAB]username[TAB]credential" ë¼ì¸ë“¤ì„ ì¶œë ¥
#         prints lines of "group[TAB]name[TAB]host[TAB]port[TAB]username[TAB]credential" to STDOUT.
# @return {int} jq ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ë¹„-0, ì •ìƒ ì‹œ 0
#         0 on success; non-zero if jq fails.
##
_get_filtered_raw_connections() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  jq -r '
    .connections
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)"
  ' "$CONFIG_FILE"
}

##
# í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ì„¤ì • íŒŒì¼ / masterkey ê²½ë¡œë¥¼ ë°°ë„ˆ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Print configuration / masterkey paths as a banner before connection tables.
#
# @param $1 {none} ì—†ìŒ / none
#
# @return {int} í•­ìƒ 0 / always 0.
##
print_config_summary_banner() {
  local line
  line="*****************************************************************"
  printf '%s\n' "$line"
  printf 'âš™ï¸  configuration: %s\n' "${CONFIG_FILE}"
  printf 'âš™ï¸  masterkey    : %s\n' "${MASTERKEY_FILE:-<not set>}"
  printf '%s\n' "$line"
}

##
# íƒ­ êµ¬ë¶„ ì›ì‹œ ë¬¸ìì—´ì„ ì¸ë±ìŠ¤ ì»¬ëŸ¼(#)ì´ í¬í•¨ëœ í‘œ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Render a tab-separated raw string as a table with index (#) column.
#
# @param $1 {string} raw "group[TAB]name[TAB]host[TAB]port[TAB]username[TAB]credential" í˜•ì‹ì˜ ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´
#                      multi-line string in "group[TAB]name[TAB]host[TAB]port[TAB]username[TAB]credential" format
#
# @return {int} ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 1, í‘œ ì¶œë ¥ ì‹œ 0
#         1 when no data; 0 when table is printed successfully.
##
print_raw_as_table() {
  local raw="$1"

  if [[ -z "$raw" ]]; then
    echo "ì €ì¥ëœ ì—°ê²°ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    local n=0 group name host port user cred display_cred

    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      n=$((n+1))
      local idx
      printf -v idx "%04d" "$n"

      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"
     
      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      temp_buffer+="${idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    # column ê²°ê³¼ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í—¤ë” ê¸¸ì´ë¥¼ êµ¬í•´ì„œ
    # '-' êµ¬ë¶„ì„ ê³¼ '=' êµ¬ë¶„ì„ ì„ í•¨ê»˜ ë§Œë“ ë‹¤.
    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}

    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    # ìœ„/ì•„ë˜ '=' ë¼ì¸ ì¶”ê°€
    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential"
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------"

    local n=0 group name host port user cred display_cred idx
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      n=$((n+1))
      printf -v idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" "$idx" "$group" "$name" "$host" "$port" "$user" "$display_cred"
    done <<< "$raw"
  fi

  return 0
}

##
# ì¸ë±ìŠ¤ ì—†ì´ ê¸°ë³¸ ì»¬ëŸ¼ë§Œ í¬í•¨í•˜ëŠ” í‘œë¥¼ ì¶œë ¥í•œë‹¤.
# Render a table without index column using only base fields.
#
# @param $1 {string} raw "group[TAB]name[TAB]tost[TAB]port[TAB]user[TAB]credential" í˜•ì‹ì˜ ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´
#
# @return {int} ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 1, í‘œ ì¶œë ¥ ì‹œ 0
#         1 when no data; 0 when table is printed successfully.
##
print_raw_as_table_no_index() {
  local raw="$1"
  if [[ -z "$raw" ]]; then
    echo "ì €ì¥ëœ ì—°ê²°ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi
  
  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    local group name host port user cred display_cred

    # '\t' ë¬¸ìë¥¼ [TAB] ìºë¦­í„°ë¡œ ë³€í™˜
    #raw="$(printf '%s' "$raw" | sed $'s/\\\\t/\t/g')"
    temp_buffer+="Group\tName\tHost\tPort\tUser\tCredential\n"
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"
     
      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      temp_buffer+="${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    # column ê²°ê³¼ë¥¼ í•œ ë²ˆ ë§Œë“¤ì–´ì„œ, í—¤ë” ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ
    # '-' êµ¬ë¶„ì„ ê³¼ '=' êµ¬ë¶„ì„ ì„ ëª¨ë‘ ìƒì„±
    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}

    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    # ìœ„/ì•„ë˜ '=' ë¼ì¸ ì¶”ê°€
    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"  
  else
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "Group" "Name" "Host" "Port" "User" "Credential"
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "-----" "----" "----" "----" "----" "----------"

    local group name host port user cred display_cred
    while IFS=$'\t' read -r group name host port user cred; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$group" "$name" "$host" "$port" "$user" "$display_cred"
    done <<< "$raw"
  fi

  return 0
}

##
# queryë¥¼ ì´ìš©í•´ connection ëª©ë¡ì„ í•„í„°ë§í•˜ê³  í‘œ í˜•íƒœë¡œ ì¶œë ¥í•œë‹¤.
# Filter connections by query and print them as a table.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search query; empty for all
#
# @return {int} ë‚´ë¶€ print_raw_as_table ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table.
##
print_connections_table() {
  local query="${1:-}"
  local raw
  raw="$(_get_filtered_raw_connections "$query")"
  print_raw_as_table "$raw"
}

##
# ë‹¨ì¼ connection í•„ë“œë“¤ì„ ë°›ì•„ ì¸ë±ìŠ¤ ì—†ëŠ” 1í–‰ í‘œë¡œ ì¶œë ¥í•œë‹¤.
# Print a single connection as a one-row table without index column.
#
# @param $1 {string} group
# @param $2 {string} name
# @param $3 {string} host
# @param $4 {string} port
# @param $5 {string} username
# @param $6 {string} credential (password ë˜ëŠ” key path)
#
# @return {int} ë‚´ë¶€ print_raw_as_table_no_index ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table_no_index.
##
print_single_connection_from_fields() {
  local group="$1"
  local name="$2"
  local host="$3"
  local port="$4"
  local username="$5"
  local credential="$6"

  #local raw="${group}\t${name}\t${host}\t${port}\t${username}\t${credential}"
  local raw="${group}"$'\t'"${name}"$'\t'"${host}"$'\t'"${port}"$'\t'"${username}"$'\t'"${credential}"
  print_raw_as_table_no_index "$raw"
}

##
# ë‹¨ì¼ connection JSON ê°ì²´ë¥¼ ë°›ì•„ ìš”ì•½ ì •ë³´ë¥¼ í‘œë¡œ ì¶œë ¥í•œë‹¤.
# Print a preview table for a single connection JSON object.
#
# @param $1 {string(json)} connection JSON ê°ì²´ ë¬¸ìì—´ / JSON string for a single connection
#
# @return {int} ë‚´ë¶€ print_raw_as_table_no_index ê²°ê³¼ ì½”ë“œ / result code from print_raw_as_table_no_index.
##
print_connection_preview_from_json() {
  local json="$1"

  local raw
  raw="$(jq -r '
    { group, name, host, port, username, credential }
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)"
  ' <<< "$json")"

  print_raw_as_table_no_index "$raw"
}

##
# ê²€ìƒ‰ì‹ìœ¼ë¡œ connection í›„ë³´ë¥¼ í•„í„°ë§í•˜ê³ , ì‚¬ìš©ìê°€ ì„ íƒí•œ í•­ëª©ì˜ JSONì„ ë°˜í™˜í•œë‹¤.
# Filter connection candidates by query and return the selected one as JSON.
#
# @param $1 {string} query ê²€ìƒ‰ì‹ (ë¹ˆ ë¬¸ìì—´ì´ë©´ ì „ì²´) / search query; empty for all
#
# @return {string} STDOUTë¡œ { __idx, group, name, host, port, username, auth_type, credential } JSON ì¶œë ¥
#         prints selected connection JSON (including __idx) to STDOUT.
# @return {int} ì„ íƒ ì·¨ì†Œ ì‹œ 1, ì„±ê³µ ì‹œ 0
#         1 on cancel; 0 on success.
##

##
# (ë°°ë„ˆ ì—†ì´) ë‹¨ì¼ connectionì„ 1í–‰ í‘œë¡œ ì¶œë ¥í•œë‹¤.
# Print a one-row table for a single connection WITHOUT configuration banner.
#
# @param $1 {string} group
# @param $2 {string} name
# @param $3 {string} host
# @param $4 {string} port
# @param $5 {string} username (encrypted or plain)
# @param $6 {string} credential (encrypted or plain)
#
# @return {int} ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ 1 / 0 on success, 1 on failure.
##
print_single_connection_no_banner() {
  local group="$1"
  local name="$2"
  local host="$3"
  local port="$4"
  local user="$5"
  local cred="$6"

  local user_dec cred_dec display_cred
  user_dec="$(decrypt_value_if_needed "$user")"
  cred_dec="$(decrypt_value_if_needed "$cred")"
  display_cred="$(format_credential_for_display "$cred_dec")"

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="Group\tName\tHost\tPort\tUser\tCredential\n"
    temp_buffer+="${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}

    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"
    printf '%s\n' "$header_line"
    printf '%s\n' "$separator"
    printf '%s\n' "$data_lines"
    printf '%s\n' "$eq_line"
  else
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "Group" "Name" "Host" "Port" "User" "Credential"
    printf -- "%s\t%s\t%s\t%s\t%s\t%s\n" "-----" "----" "----" "----" "----" "----------"
    printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred"
  fi

  return 0
}

##
# ê²€ìƒ‰ì‹ìœ¼ë¡œ connection í›„ë³´ë¥¼ í•„í„°ë§í•˜ê³ , Në²ˆì§¸ í•­ëª©ì„ ì„ íƒí•˜ì—¬ JSONì„ ë°˜í™˜í•œë‹¤.
# Filter connection candidates by query and select the N-th item, returning it as JSON.
#
# @param $1 {string} query ê²€ìƒ‰ì‹ (ë¹ˆ ë¬¸ìì—´ì´ë©´ ì „ì²´) / search query; empty for all
# @param $2 {int} number 1-based ë²ˆí˜¸(#) / 1-based index
#
# @return {string} STDOUTë¡œ { __idx, group, name, host, port, username, auth_type, credential } JSON ì¶œë ¥
#         prints selected connection JSON (including __idx) to STDOUT.
# @return {int} ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ 1 / 0 on success, 1 on failure.
##
select_connection_by_number() {
  local query="${1:-}"
  local number="${2:-}"

  if [[ -z "$number" ]]; then
    echo "[ERROR] --number|-n ì˜µì…˜ì—ëŠ” ìˆ«ì ê°’ì´ í•„ìš”í•©ë‹ˆë‹¤." >&2
    return 1
  fi
  if ! [[ "$number" =~ ^[0-9]+$ ]]; then
    echo "[ERROR] --number|-n ê°’ì€ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤: $number" >&2
    return 1
  fi

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local candidates
  candidates="$(jq -c '     .connections     | to_entries     | map(.key as $idx | .value + {"__idx": $idx })     | map(select('"$filter"'))     | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])   ' "$CONFIG_FILE")"

  local total
  total="$(jq -r 'length' <<< "$candidates")"
  if [[ "$total" == "0" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  if (( number < 1 || number > total )); then
    echo "[ERROR] ë²ˆí˜¸(#) ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: $number (í—ˆìš©: 1 ~ $total)" >&2
    return 1
  fi

  local idx0=$((number - 1))
  local selected
  selected="$(jq -c --argjson i "$idx0" '.[$i]' <<< "$candidates")"

  local group name host port user cred
  group="$(jq -r '.group' <<< "$selected")"
  name="$(jq -r '.name' <<< "$selected")"
  host="$(jq -r '.host' <<< "$selected")"
  port="$(jq -r '.port // 22' <<< "$selected")"
  user="$(jq -r '.username' <<< "$selected")"
  cred="$(jq -r '.credential' <<< "$selected")"

  # ì„ íƒëœ í•­ëª© 1ê±´ë§Œ ì¶œë ¥ (ë°°ë„ˆ ì—†ìŒ)
  print_single_connection_no_banner "$group" "$name" "$host" "$port" "$user" "$cred" >&2

  # cmd_connectì˜ ì¶œë ¥ê³¼ êµ¬ë¶„ì„ ìœ„í•´ 1ì¤„ ë„ì›€
  echo >&2

  printf '%s' "$selected"
  return 0
}

select_connection_interactively() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0
  local group name host port user cred idx display_cred

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # ë³´ì—¬ì¤„ ë°ì´í„°ëŠ” decript
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len separator eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v separator '%*s' "$header_len" ''
    separator="${separator// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$separator"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # ë³´ì—¬ì¤„ ë°ì´í„°ëŠ” decript
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred" >&2
    done <<< "$raw"
  fi

  local sel
  local prompt_msg="âœ¨  ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” [1 ~ $n]: "
  while true; do
    read -r -p "$prompt_msg" sel
    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi
    if ! [[ "$sel" =~ ^[0-9]+$ ]] || (( sel < 1 || sel > n )); then
      prompt_msg="â—  ì…ë ¥í•œ ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë²ˆí˜¸(#)ë¥¼ ì„ íƒí•˜ì„¸ìš” [1 ~ $n]: "
      continue
    fi
    break
  done

  local selected_idx="${idx_map[$sel]}"

  jq -c --argjson i "$selected_idx" '
    .connections
    | to_entries
    | .[$i]
    | { __idx: .key } + .value
  ' "$CONFIG_FILE"
}

# -----------------------------------------------------------------------------
# UTF-8 ë¬¸ìë¥¼ 1ê°œ ì½ëŠ”ë‹¤. (í•œêµ­ì–´ í¬í•¨)
# - í•œêµ­ì–´/English: read one UTF-8 character from stdin
# @return {string} ì½ì€ ë¬¸ì 1ê°œë¥¼ echo ë¡œ ë°˜í™˜. Enter ì‹œ ë¹ˆ ë¬¸ìì—´ ë°˜í™˜.
# -----------------------------------------------------------------------------
_read_utf8_char() {
  local c
  IFS= read -r -s -n 1 c || return 1

  # Enter
  if [[ "$c" == $'\n' || "$c" == $'\r' ]]; then
    echo ""
    return 0
  fi

  # ì¼ë°˜ ASCII
  local ord
  ord=$(printf '%d' "'$c" 2>/dev/null)
  if [[ -z "$ord" ]]; then
    # ì¼ë¶€ í™˜ê²½ì—ì„œ printf '%d' "'$c" ê°€ ë¹„ì •ìƒì¸ ê²½ìš°ê°€ ìˆì–´ fallback
    echo "$c"
    return 0
  fi

  # UTF-8 ë©€í‹°ë°”ì´íŠ¸ ì²˜ë¦¬
  local need=0
  if (( ord >= 0 && ord <= 127 )); then
    need=0
  elif (( ord >= 192 && ord <= 223 )); then
    need=1
  elif (( ord >= 224 && ord <= 239 )); then
    need=2
  elif (( ord >= 240 && ord <= 247 )); then
    need=3
  else
    need=0
  fi

  if (( need > 0 )); then
    local rest=""
    IFS= read -r -s -n "$need" rest || true
    echo "${c}${rest}"
  else
    echo "$c"
  fi

  return 0
}

# -----------------------------------------------------------------------------
# UTF-8 ì•ˆì „í•œ í•œ ì¤„ ì…ë ¥ê¸° (Backspace/CTRL+U ì§€ì›)
# - í•œêµ­ì–´/English: line editor that redraws line, safe for UTF-8
#
# @param $1 {string} prompt ì…ë ¥ í”„ë¡¬í”„íŠ¸(ASCII ê¶Œì¥). ì˜ˆ: "> "
# @param $2 {string} default ê¸°ë³¸ê°’(Enter ì‹œ ì ìš©)
# @return {string} ì…ë ¥ ë¬¸ìì—´ì„ echo ë¡œ ë°˜í™˜
# -----------------------------------------------------------------------------
read_line_utf8() {
  local prompt="$1"
  local default_value="${2:-}"
  local buf=""
  local ch

  local EL=$'\033[K'
  if command -v tput >/dev/null 2>&1; then
    EL="$(tput el)"
  fi

  local old_stty
  old_stty="$(stty -g 2>/dev/null)"
  stty -echo 2>/dev/null

  # ìµœì´ˆ 1íšŒëŠ” promptë§Œ ì¶œë ¥ (ì—¬ê¸°ì„œ ë¼ì¸ì„ ì§€ìš°ì§€ ì•ŠìŒ)
  printf '%s' "$prompt" >&2

  while true; do
    IFS= read -r -s -n 1 ch || break

    # Enterë§Œ ëˆŒë €ì„ ë•Œ: bash readëŠ” newlineì„ delimiterë¡œ ì†Œë¹„í•´ì„œ chê°€ ë¹ˆ ë¬¸ìì—´ì´ ë¨
    # => ë¹ˆ ë¬¸ìì—´ë„ Enterë¡œ ê°„ì£¼í•˜ê³  ì¢…ë£Œ
    if [[ -z "$ch" || "$ch" == $'\n' || "$ch" == $'\r' ]]; then
      break
    fi

    if [[ "$ch" == $'\x7f' || "$ch" == $'\x08' ]]; then
      if [[ -n "$buf" ]]; then
        buf="${buf%?}"  # UTF-8 ì•ˆì „: ë§ˆì§€ë§‰ ë¬¸ì 1ê°œ ì œê±°
      fi
      # promptëŠ” í•­ìƒ ìœ ì§€í•˜ê³ , ì”ìƒë§Œ ì œê±°
      printf '\r%s%s%s' "$prompt" "$buf" "$EL" >&2
      continue
    fi

    if [[ "$ch" == $'\x15' ]]; then
      buf=""
      printf '\r%s%s%s' "$prompt" "$buf" "$EL" >&2
      continue
    fi

    buf+="$ch"
    printf '\r%s%s%s' "$prompt" "$buf" "$EL" >&2
  done

  stty "$old_stty" 2>/dev/null
  printf '\n' >&2

  if [[ -z "$buf" && -n "$default_value" ]]; then
    buf="$default_value"
  fi

  printf '%s' "$buf"
  return 0
}

# -----------------------------------------------------------------------------
# UTF-8 ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ê¸° (ë§ˆìŠ¤í‚¹ ì¶œë ¥)
# - í•œêµ­ì–´/English: masked password input (****), safe for UTF-8 editing
#
# @param $1 {string} prompt ì…ë ¥ í”„ë¡¬í”„íŠ¸ (ì˜ˆ: "       > [****]: ")
# @param $2 {string} default_value ê¸°ë³¸ê°’(Enter ì‹œ ìœ ì§€í•  ê°’). ë¹ˆ ë¬¸ìì—´ì´ë©´ EnterëŠ” ë¹ˆ ê°’.
# @return {string} ì…ë ¥ ë¬¸ìì—´(í‰ë¬¸)ì„ echoë¡œ ë°˜í™˜
# -----------------------------------------------------------------------------
_read_password_utf8_masked() {
  local prompt="$1"
  local default_value="${2:-}"
  local buf=""
  local ch

  local EL=$'\033[K'
  if command -v tput >/dev/null 2>&1; then
    EL="$(tput el)"
  fi

  local old_stty
  old_stty="$(stty -g 2>/dev/null)"

  # í˜¹ì‹œ ì˜ˆì™¸/ì¤‘ë‹¨ ì‹œì—ë„ stty ë³µêµ¬ë˜ë„ë¡ (í•¨ìˆ˜ ë²”ìœ„ì—ì„œë§Œ)
  trap 'stty "$old_stty" 2>/dev/null' INT TERM

  stty -echo 2>/dev/null

  # ìµœì´ˆ í”„ë¡¬í”„íŠ¸ ì¶œë ¥
  printf '%s' "$prompt" >&2

  while true; do
    IFS= read -r -s -n 1 ch || break

    # Enter ì²˜ë¦¬ (ë¹ˆ ë¬¸ìì—´ë„ Enter)
    if [[ -z "$ch" || "$ch" == $'\n' || "$ch" == $'\r' ]]; then
      break
    fi

    # Backspace (DEL/BS)
    if [[ "$ch" == $'\x7f' || "$ch" == $'\x08' ]]; then
      if [[ -n "$buf" ]]; then
        buf="${buf%?}"  # UTF-8 ë¬¸ì ë‹¨ìœ„ ì‚­ì œ
      fi

      # ë§ˆìŠ¤í‚¹ ë¬¸ìì—´ ì¬ìƒì„±
      local stars=""
      if [[ -n "$buf" ]]; then
        stars="$(printf '%*s' "${#buf}" '' | tr ' ' '*')"
      fi

      printf '\r%s%s%s' "$prompt" "$stars" "$EL" >&2
      continue
    fi

    # Ctrl+U: ë¼ì¸ ì „ì²´ ì‚­ì œ
    if [[ "$ch" == $'\x15' ]]; then
      buf=""
      printf '\r%s%s%s' "$prompt" "" "$EL" >&2
      continue
    fi

    # ì¼ë°˜ ë¬¸ì ì¶”ê°€
    buf+="$ch"

    local stars=""
    stars="$(printf '%*s' "${#buf}" '' | tr ' ' '*')"
    printf '\r%s%s%s' "$prompt" "$stars" "$EL" >&2
  done

  stty "$old_stty" 2>/dev/null
  trap - INT TERM
  printf '\n' >&2

  # Enterë§Œ ëˆŒë €ê³  default_valueê°€ ìˆìœ¼ë©´ default ì ìš©(=ê¸°ì¡´ ê°’ ìœ ì§€)
  if [[ -z "$buf" && -n "$default_value" ]]; then
    buf="$default_value"
  fi

  printf '%s' "$buf"
  return 0
}

# -----------------------------------------------------------------------------
# credential ì…ë ¥ í”„ë¡¬í”„íŠ¸ (password/key ê³µí†µ)
# - í•œêµ­ì–´/English: unified credential prompt for password/key
#
# @param $1 {string} icon  ì•„ì´ì½˜(ì˜ˆ: ğŸ”‘)
# @param $2 {string} field í•„ë“œëª…(ì˜ˆ: password, key path)
# @param $3 {string} auth_type "password" | "key"
# @param $4 {string} current ê¸°ì¡´ ê°’ (passwordì˜ ê²½ìš° ì‹¤ì œ ê°’ì€ ìˆ¨ê¸°ë˜ Enter=keep)
#
# @return {string} ì…ë ¥ ê²°ê³¼ë¥¼ echoë¡œ ë°˜í™˜
#   - password: í‰ë¬¸ ë°˜í™˜(í‘œì‹œëŠ” ****), Enterë©´ ê¸°ì¡´ ê°’ ìœ ì§€
#   - key: ê²½ë¡œ ë¬¸ìì—´ ë°˜í™˜, Enterë©´ ê¸°ì¡´ ê°’ ìœ ì§€
# -----------------------------------------------------------------------------
prompt_credential_with_icon() {
  local icon="$1"
  local field="$2"
  local auth_type="$3"
  local current="${4:-}"
  local input input_prompt

  # ì•ˆë‚´ ë¼ì¸ (ì´ëª¨ì§€ í¬í•¨, í¸ì§‘ ì—†ìŒ)
  printf '\r\033[K' >&2
  printf " * %s  '%s' ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n" "${icon}" "${field}" >&2

  if [[ "$auth_type" == "password" ]]; then
    # ê¸°ì¡´ UX ìœ ì§€: > [****]:
    input_prompt="       > "
    #input_prompt+="[****]: "
    input_prompt+="[${current}]: "

    # ë§ˆìŠ¤í‚¹ ì…ë ¥ê¸° ì‚¬ìš© (Enter ì‹œ ê¸°ì¡´ ê°’ ìœ ì§€)
    input="$(_read_password_utf8_masked "$input_prompt" "$current")"
    printf '%s' "$input"
    return 0
  fi

  # key path: ê¸°ì¡´ UX ìœ ì§€: > [<path>]:
  input_prompt="       > "
  if [[ -n "$current" ]]; then
    input_prompt+="[${current}]: "
  else
    input_prompt+=": "
  fi

  # key pathëŠ” ì¼ë°˜ ì…ë ¥ (UTF-8 ì•ˆì „)
  input="$(read_line_utf8 "$input_prompt" "$current")"
  printf '%s' "$input"
  return 0
}

##
# ì•„ì´ì½˜ê³¼ í•„ë“œëª…ì„ PROMPT_LABEL_WIDTH ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì…ë ¥ì„ ë°›ëŠ”ë‹¤.
# Prompt with an icon and field name aligned by PROMPT_LABEL_WIDTH.
#
# history
# - 20251216: ê¸€ì ë°€ë¦¼ ìˆ˜ì •
#
# @param $1 {string} icon í”„ë¡¬í”„íŠ¸ì— ì‚¬ìš©í•  ì•„ì´ì½˜ / icon to display
# @param $2 {string} field í•„ë“œ ì´ë¦„ / field name
# @param $3 {string|empty} current í˜„ì¬/ê¸°ë³¸ ê°’ / current/default value
#
# @return {string} STDOUTë¡œ ìµœì¢… ì…ë ¥ê°’ ì¶œë ¥ / prints final input value to STDOUT.
# @return {int} í•­ìƒ 0 / always 0.
##
prompt_with_icon() {
  local icon="$1"
  local field="$2"
  local current="${3:-}"
  local raw label input input_prompt

  raw="${icon}  ${field}"
  printf -v label "%-*s" "$PROMPT_LABEL_WIDTH" "$raw"

  # ë¼ì¸ ì”ìƒ ë°©ì§€
  printf '\r\033[K' >&2

  # 1) ì•ˆë‚´ ë¼ì¸(ì´ëª¨ì§€ í¬í•¨)ì€ ë³„ë„ ì¶œë ¥ (ì—¬ê¸°ì„œëŠ” ì»¤ì„œ í¸ì§‘ì´ ì—†ìŒ)
  if [[ -n "$current" ]]; then
    printf " * %s  '%s' ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n" "${icon}" "${field}" >&2
  else
    printf " * %s  '%s' ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n" "${icon}" "${field}" >&2
  fi

  # 2) ì‹¤ì œ ì…ë ¥ ë¼ì¸(íƒ€ì´í•‘í•˜ëŠ” ì¤„) - ê¸°ì¡´ UX ìœ ì§€: > [default]:
  input_prompt="       > "
  if [[ -n "$current" ]]; then
    input_prompt+="[${current}]: "
  else
    input_prompt+=": "
  fi

  # UTF-8 ì•ˆì „ ì…ë ¥ê¸° ì ìš© (í•œê¸€ ì…ë ¥/ì‚­ì œ ì‹œ ì”ìƒ ë° ì»¤ì„œ ë¬¸ì œ ì™„í™”)
  # Enter ì…ë ¥ ì‹œ default(current) ê°’ ì ìš©
  input="$(read_line_utf8 "$input_prompt" "$current")"

  printf '%s' "$input"
}

# =======================================
# JSON update helpers
# =======================================

##
# ì„ íƒëœ connectionì˜ ì¸ë±ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œìš´ ê°’ë“¤ë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Update a connection (by its index) with new values and output the full updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
# @param $2 {string} new_group
# @param $3 {string} new_name
# @param $4 {string} new_host_type
# @param $5 {string} new_host
# @param $6 {string} new_port (ë¬¸ìì—´, jqì—ì„œ ìˆ«ìë¡œ ë³€í™˜) / port as string (converted to number in jq)
# @param $7 {string} new_username
# @param $8 {string} new_auth_type
# @param $9 {string} new_credential
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_modify() {
  local selected_json="$1"
  local new_group="$2"
  local new_name="$3"
  local new_host_type="$4"
  local new_host="$5"
  local new_port="$6"
  local new_username="$7"
  local new_auth_type="$8"
  local new_credential="$9"

  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" \
     --arg group "$new_group" \
     --arg name "$new_name" \
     --arg host_type "$new_host_type" \
     --arg host "$new_host" \
     --arg port "$new_port" \
     --arg username "$new_username" \
     --arg auth_type "$new_auth_type" \
     --arg credential "$new_credential" \
     '
      .connections[$i].group        = $group
      | .connections[$i].name       = $name
      | .connections[$i].host_type  = $host_type
      | .connections[$i].host       = $host
      | .connections[$i].port       = ($port | tonumber)
      | .connections[$i].username   = $username
      | .connections[$i].auth_type  = $auth_type
      | .connections[$i].credential = $credential
     ' "$CONFIG_FILE"
}

##
# ì„ íƒëœ connectionì„ ì‚­ì œí•œ ìƒˆë¡œìš´ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Delete the selected connection from the list and output the updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_delete() {
  local selected_json="$1"
  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" 'del(.connections[$i])' "$CONFIG_FILE"
}

##
# ì„ íƒëœ connectionì˜ groupë§Œ ìƒˆ ê°’ìœ¼ë¡œ ë³€ê²½í•œ ì „ì²´ config JSONì„ ìƒì„±í•œë‹¤.
# Change only the group of the selected connection and output the updated config JSON.
#
# @param $1 {string(json)} selected_json __idxë¥¼ í¬í•¨í•œ ì„ íƒëœ connection JSON / selected connection JSON with __idx
# @param $2 {string} new_group ìƒˆ group ê°’ / new group value
#
# @return {string} STDOUTë¡œ ìˆ˜ì •ëœ ì „ì²´ config JSON ì¶œë ¥ / prints updated full config JSON to STDOUT.
# @return {int} jq ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 if jq succeeds; non-zero otherwise.
##
update_connection_move_group() {
  local selected_json="$1"
  local new_group="$2"
  local idx
  idx="$(jq -r '.__idx' <<< "$selected_json")"

  jq --argjson i "$idx" --arg group "$new_group" '
    .connections[$i].group = $group
  ' "$CONFIG_FILE"
}

# =======================================
# Commands
# =======================================

##
# sshctl -l|--list-all [expr] ëª…ë ¹ì„ êµ¬í˜„í•œë‹¤.
# Implement sshctl -l|--list-all [expr] command.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} print_connections_table ê²°ê³¼ ì½”ë“œ / result code from print_connections_table.
##
cmd_list() {
  local query="${1:-}"
  print_connections_table "$query"
}

##
# ìƒˆ SSH connection ì •ë³´ë¥¼ ì¸í„°ë™í‹°ë¸Œí•˜ê²Œ ì…ë ¥ í›„ configurationì— ì¶”ê°€í•œë‹¤.
# Add a new SSH connection interactively and append it to configuration.
#
# @param $1 ì—†ìŒ (ëª¨ë“  ì…ë ¥ì€ í”„ë¡¬í”„íŠ¸ë¡œ ë°›ìŒ) / none (all inputs are prompted interactively)
#
# @return {int} ì„±ê³µ ì‹œ 0, ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on validation or save failures.
##
cmd_add_connection() {
  ensure_config_file

  log INFO "ìƒˆ connection ì •ë³´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤."

  echo "-----------------------------------------------------------"

  local group name host_type host port username auth_type credential host_input port_input

  # group
  while true; do
    group="$(prompt_with_icon "ğŸ“" "group" "default")"
    if validate_non_empty "group" "$group"; then
      break
    fi
  done

  # name
  while true; do
    name="$(prompt_with_icon "ğŸ“›" "name" "")"
    if validate_non_empty "name" "$name"; then
      break
    fi
  done

  # host_type
  while true; do
    host_type="$(prompt_with_icon "ğŸŒ" "host_type (ipv4|ipv6|domain)" "ipv4")"
    if validate_host_type "$host_type"; then
      break
    fi
  done

  # host (+ optional port)
  while true; do
    host_input="$(prompt_with_icon "ğŸŒ" "host" "")"
    if [[ "$host_input" =~ ^(.+):([0-9]+)$ ]]; then
      host="${BASH_REMATCH[1]}"
      port_input="${BASH_REMATCH[2]}"
    else
      host="$host_input"
      port_input="22"
    fi
    if ! validate_non_empty "host" "$host"; then
      continue
    fi
    if ! validate_host_by_type "$host_type" "$host"; then
      continue
    fi
    break
  done

  # port
  while true; do
    port="$(prompt_with_icon "ğŸ”Œ" "port" "$port_input")"
    if validate_port "$port"; then
      break
    fi
  done

  # username
  while true; do
    username="$(prompt_with_icon "ğŸ‘¤" "username" "")"
    if validate_non_empty "username" "$username"; then
      break
    fi
  done

  # auth_type
  while true; do
    auth_type="$(prompt_with_icon "ğŸ”" "auth_type (password|key)" "password")"
    if validate_auth_type "$auth_type"; then
      break
    fi
  done

  # credential
  if [[ "$auth_type" == "password" ]]; then
    while true; do
      credential="$(prompt_credential_with_icon "ğŸ”‘" "password" "password" "")"
      if validate_non_empty "password" "$credential"; then
        break
      fi
    done
  else
    while true; do
      credential="$(prompt_credential_with_icon "ğŸ”‘" "key path" "key" "")"
      credential="$(resolve_path_abs "$credential")"
      if validate_non_empty "key path" "$credential"; then
        break
      fi
    done
  fi

  echo "-----------------------------------------------------------"

  # 'ë¯¼ê°ì •ë³´' ì•”í˜¸í™” ì ìš©
  username_enc="$(encrypt_value "$username")"
  credential_enc="$(encrypt_value "$credential")"

  local new_json
  new_json="$(jq --arg group "$group" \
                 --arg name "$name" \
                 --arg host_type "$host_type" \
                 --arg host "$host" \
                 --arg port "$port" \
                 --arg username "$username_enc" \
                 --arg auth_type "$auth_type" \
                 --arg credential "$credential_enc" \
                 '
    .connections += [{
      "group": $group,
      "name": $name,
      "host_type": $host_type,
      "host": $host,
      "port": ($port | tonumber),
      "username": $username,
      "auth_type": $auth_type,
      "credential": $credential
    }]
  ' "$CONFIG_FILE")"

  save_connections_json <<< "$new_json"

  local raw_line="${group}\t${name}\t${host}\t${port}\t${username}\t${credential}"
  local temp_buffer="Group\tName\tHost\tPort\tUser\tCredential\n${raw_line}\n"

  if command -v column >/dev/null 2>&1; then
    local rendered header_line data_lines header_len eq_line dash_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"

    echo "$eq_line"
    echo "ìƒì„±ëœ connection:"
    echo "$header_line"
    echo "$dash_line"
    echo "$data_lines"
  else
    echo "=============================="
    echo "ìƒì„±ëœ connection:"
    print_single_connection_from_fields "$group" "$name" "$host" "$port" "$username" "$credential"
  fi

  # auth_type ì´ password ì¸ ê²½ìš°, configuration ì €ì¥ í›„ sshpass ìë™ ì„¤ì¹˜ ì‹œë„
  if [[ "$auth_type" == "password" ]]; then
    if ! command -v sshpass >/dev/null 2>&1; then
      echo "INFO: auth_type=password ì´ë¯€ë¡œ sshpass ì„¤ì¹˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤." >&2
      if ! install_sshpass_if_missing; then
        echo "WARN: sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´í›„ password ê¸°ë°˜ ì ‘ì† ì‹œ sshpass ê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
      fi
    fi
  fi
}

##
# ê¸°ë³¸/ê²€ìƒ‰ expr ì— ë”°ë¼ ì‹¤ì œ SSH ì ‘ì†ì„ ìˆ˜í–‰í•œë‹¤.
# Perform actual SSH connection based on optional search expr (default/select & connect).
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} password ëª¨ë“œì—ì„œëŠ” ssh ë°˜í™˜ ì½”ë“œ, key ëª¨ë“œì—ì„œëŠ” exec ssh í›„ ë³µê·€í•˜ì§€ ì•ŠìŒ.
#         In password mode: ssh exit code; in key mode: exec ssh (no return).
##
cmd_connect() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  if [[ -n "${CONNECT_NUMBER:-}" ]]; then
    selected_json="$(select_connection_by_number "$query" "$CONNECT_NUMBER")" || return 1
  else
    selected_json="$(select_connection_interactively "$query")" || return 1
  fi

  local host username port auth_type credential
  host="$(jq -r '.host' <<< "$selected_json")"
  username_enc="$(jq -r '.username' <<< "$selected_json")"
  username="$(decrypt_value_if_needed "$username_enc")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"
  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"
  credential_enc="$(jq -r '.credential' <<< "$selected_json")"
  credential="$(decrypt_value_if_needed "$credential_enc")"

  validate_port "$port" || die "port ê°’ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: $port"

  local ssh_opts=(-o StrictHostKeyChecking=accept-new)
  
  if [[ "$auth_type" == "password" ]]; then
    if ! command -v sshpass >/dev/null 2>&1; then
      echo "â—  sshpass ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•Šì•„, ì´ë²ˆ ì ‘ì†ì€ ì·¨ì†Œí•˜ê³  sshpass ì„¤ì¹˜ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤." >&2
      if ! install_sshpass_if_missing; then
        echo "â—  sshpass ì„¤ì¹˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì„¤ì¹˜í•œ í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ ì£¼ì„¸ìš”." >&2
      fi
      return 1
    fi    
    echo 
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—                                          â—â—â—" >&2
    echo "â—â—â— ê²½ê³ : sshpass + password ë°©ì‹ ì ‘ì†ì…ë‹ˆë‹¤ â—â—â—" >&2
    echo "â—â—â—                                          â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo "â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—" >&2
    echo 
    sshpass -p "$credential" ssh "${ssh_opts[@]}" -p "$port" "${username}@${host}"
  else
    if [[ ! -f "$credential" ]]; then
      die "key file not found: $credential"
    fi
    echo 
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”                                          ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ” ì•ˆì‹¬: 'OpenSSH Key ì¸ì¦ë°©ì‹' ì ‘ì†ì…ë‹ˆë‹¤. ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”                                          ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”" >&2
    echo 
    exec ssh "${ssh_opts[@]}" -p "$port" -i "$credential" "${username}@${host}"
  fi
}

##
# sshctl -m|--modify-connection [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì„ ìˆ˜ì •í•œë‹¤.
# Implement sshctl -m|--modify-connection [expr] and modify a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„±ê³µ ì‹œ 0, ì„ íƒ/ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on selection/validation/save failures.
##
cmd_modify_connection() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  echo "-----------------------------------------------------------"

  local group name host_type host port username auth_type credential
  group="$(jq -r '.group' <<< "$selected_json")"
  name="$(jq -r '.name' <<< "$selected_json")"
  host_type="$(jq -r '.host_type' <<< "$selected_json")"
  host="$(jq -r '.host' <<< "$selected_json")"
  port="$(jq -r '.port // 22' <<< "$selected_json")"

  # -------------------------------
  # â˜… username / credential ë³µí˜¸í™” ì ìš©
  # -------------------------------
  username_enc="$(jq -r '.username' <<< "$selected_json")"
  username="$(decrypt_value_if_needed "$username_enc")"
  credential_enc="$(jq -r '.credential' <<< "$selected_json")"
  credential="$(decrypt_value_if_needed "$credential_enc")"

  auth_type="$(jq -r '.auth_type' <<< "$selected_json")"

  if [[ "$host" =~ ^(.+):([0-9]+)$ ]]; then
    host="${BASH_REMATCH[1]}"
    port="${BASH_REMATCH[2]}"
  fi

  local new_group new_name new_host_type new_host new_port new_username new_auth_type new_credential
  local host_input port_input tmp

  # group
  while true; do
    new_group="$(prompt_with_icon "ğŸ“" "group" "$group")"
    if [[ -z "$new_group" ]]; then
      new_group="$group"
    fi
    if validate_non_empty "group" "$new_group"; then
      break
    fi
  done

  # name
  while true; do
    new_name="$(prompt_with_icon "ğŸ“›" "name" "$name")"
    if [[ -z "$new_name" ]]; then
      new_name="$name"
    fi
    if validate_non_empty "name" "$new_name"; then
      break
    fi
  done

  # host_type
  while true; do
    new_host_type="$(prompt_with_icon "ğŸŒ" "host_type (ipv4|ipv6|domain)" "$host_type")"
    if [[ -z "$new_host_type" ]]; then
      new_host_type="$host_type"
    fi
    if validate_host_type "$new_host_type"; then
      break
    fi
  done

  # host (+ optional port)
  while true; do
    host_input="$(prompt_with_icon "ğŸŒ" "host" "$host")"
    if [[ -z "$host_input" ]]; then
      host_input="$host"
    fi
    if [[ "$host_input" =~ ^(.+):([0-9]+)$ ]]; then
      new_host="${BASH_REMATCH[1]}"
      port_input="${BASH_REMATCH[2]}"
    else
      new_host="$host_input"
      port_input="$port"
    fi
    if ! validate_non_empty "host" "$new_host"; then
      continue
    fi
    if ! validate_host_by_type "$new_host_type" "$new_host"; then
      continue
    fi
    break
  done

  # port
  while true; do
    new_port="$(prompt_with_icon "ğŸ”Œ" "port" "$port_input")"
    if [[ -z "$new_port" ]]; then
      new_port="$port"
    fi
    if validate_port "$new_port"; then
      break
    fi
  done

  # username
  while true; do
    new_username="$(prompt_with_icon "ğŸ‘¤" "username" "$username")"
    if [[ -z "$new_username" ]]; then
      new_username="$username"
    fi
    if validate_non_empty "username" "$new_username"; then
      break
    fi
  done

  # auth_type
  while true; do
    new_auth_type="$(prompt_with_icon "ğŸ”" "auth_type (password|key)" "$auth_type")"
    if [[ -z "$new_auth_type" ]]; then
      new_auth_type="$auth_type"
    fi
    if validate_auth_type "$new_auth_type"; then
      break
    fi
  done

  # credential
  if [[ "$new_auth_type" == "password" ]]; then
    local old_pw="$credential"
    while true; do
      tmp="$(prompt_credential_with_icon "ğŸ”‘" "password" "password" "$old_pw")"
      if [[ -z "$tmp" ]]; then
        new_credential="$old_pw"
        break
      fi
      new_credential="$tmp"
      break
    done
  else
    while true; do
      tmp="$(prompt_credential_with_icon "ğŸ”‘" "key path" "key" "$credential")"
      if [[ -z "$tmp" ]]; then
        new_credential="$credential"
      else
        new_credential="$(resolve_path_abs "$tmp")"
      fi
      if validate_non_empty "key path" "$new_credential"; then
        break
      fi
    done
    printf '\n'
  fi

  echo "-----------------------------------------------------------"

  local new_json
  # -------------------------------
  # â˜… ì €ì¥ ì§ì „ ì•”í˜¸í™” ì ìš©
  # -------------------------------
  new_username_enc="$(encrypt_value "$new_username")"
  new_credential_enc="$(encrypt_value "$new_credential")"

  new_json="$(update_connection_modify "$selected_json" \
                  "$new_group" "$new_name" "$new_host_type" "$new_host" "$new_port" \
                  "$new_username_enc" "$new_auth_type" "$new_credential_enc")"

  save_connections_json <<< "$new_json"

  echo "âœ¨  ìˆ˜ì • í›„ connection:"
  print_single_connection_from_fields "$new_group" "$new_name" "$new_host" "$new_port" "$new_username" "$new_credential"
}

##
# sshctl -mc|--modify-credential [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì—¬ëŸ¬ connectionì˜ password(credential)ë¥¼ ì¼ê´„ ë³€ê²½í•œë‹¤.
# Implement sshctl -mc|--modify-credential [expr] to bulk-update password credentials for multiple connections.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„±ê³µ ì‹œ 0, ì„ íƒ/ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ë˜ëŠ” ì·¨ì†Œ ì‹œ ë¹„-0
#         0 on success; non-zero on selection/validation/save failures or cancel.
##
cmd_modify_credential() {
  ensure_config_file

  local query="${1:-}"

  # 1) ëŒ€ìƒ index(__idx) ëª©ë¡ ì–»ê¸° (password ë°©ì‹ë§Œ)
  local -a idxs=()
  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idxs+=( "$line" )
  done < <(select_indices_for_modify_credential "$query") || return 1

  if (( ${#idxs[@]} == 0 )); then
    return 1
  fi

  # 2) ìƒˆ password ì…ë ¥ (ê¸°ë³¸ê°’/ì´ì „ê°’ ì—†ìŒ)
  echo "-----------------------------------------------------------"
  local new_password=""
  while true; do
    new_password="$(prompt_credential_with_icon "ğŸ”‘" "password" "password" "")"
    if validate_non_empty "password" "$new_password"; then
      break
    fi
  done
  echo "-----------------------------------------------------------"

  # 3) 'ë¯¼ê°ì •ë³´' ì•”í˜¸í™” ì ìš©
  local new_credential_enc
  new_credential_enc="$(encrypt_value "$new_password")"

  # 4) ì„ íƒëœ ì—¬ëŸ¬ connectionì— credential ì ìš© (ë‹¨ì¼ jqë¡œ ì¼ê´„ ì—…ë°ì´íŠ¸)
  local idxs_json
  idxs_json="$(printf '%s\n' "${idxs[@]}" | jq -R 'tonumber' | jq -s '.')"

  local new_json
  new_json="$(jq --argjson idxs "$idxs_json" --arg credential "$new_credential_enc" '
    reduce $idxs[] as $i (.;
      .connections[$i].credential = $credential
    )
  ' "$CONFIG_FILE")"

  save_connections_json <<< "$new_json"

  # 5) ë³€ê²½ëœ connection ëª©ë¡ ì¶œë ¥
  echo "âœ¨  ìˆ˜ì • í›„ connection:"
  local preview_raw=""
  local idx
  for idx in "${idxs[@]}"; do
    local row
    row="$(jq -r --argjson i "$idx" '
      .connections
      | to_entries
      | .[$i]
      | "\(.value.group)\t\(.value.name)\t\(.value.host)\t\(.value.port // 22)\t\(.value.username)\t\(.value.credential)"
    ' "$CONFIG_FILE")"
    if [[ -n "$row" ]]; then
      preview_raw+="${row}"$'\n'
    fi
  done

  print_raw_as_table_no_index "$preview_raw"
}

select_indices_for_delete() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select('"$filter"'))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." >&2
    return 1
  fi

  local idx_map=()
  local n=0 group name host port user cred idx

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi
      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      display_cred="$(format_credential_for_display "$cred")"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${display_cred}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len dash_line eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"    >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$dash_line"  >&2
    printf '%s\n' "$data_lines" >&2
    printf '%s\n' "$eq_line"    >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      # -------------------------------
      # â˜… ë¯¼ê°ì •ë³´ ë³µí˜¸í™” ì ìš©
      # -------------------------------
      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"

      # credential ì¶œë ¥ ì •ì±…ì€ ë³µí˜¸í™”ëœ ê°’ ê¸°ì¤€
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      display_cred="$(format_credential_for_display "$cred")"
      local display_idx
      printf -v display_idx "%04d" "$n"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred" >&2
    done <<< "$raw"
  fi

  # ë²ˆí˜¸ ì…ë ¥ (ì‰¼í‘œ êµ¬ë¶„)
  local sel
  while true; do
    read -r -p "â“  ì‚­ì œí•  ë²ˆí˜¸(#)ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì½¤ë§ˆ(,)ë¡œ êµ¬ë¶„í•´ì„œ ì…ë ¥) [1 ~ $n] : " sel
    sel="${sel//[[:space:]]/}"  # ê³µë°± ì œê±°

    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi

    if ! [[ "$sel" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
      echo "ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ìˆ«ìë§Œ ì…ë ¥í•˜ì„¸ìš”." >&2
      continue
    fi

    local -a nums=()
    IFS=',' read -r -a nums <<< "$sel"

    local ok=true
    local v
    for v in "${nums[@]}"; do
      if (( v < 1 || v > n )); then
        echo "ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: $v (1~$n)" >&2
        ok=false
      fi
    done
    $ok && break
  done

  # ì¤‘ë³µ ì œê±° + idx_map â†’ ì‹¤ì œ JSON index ë¡œ ë³€í™˜
  local -A seen=()
  local -a real_idx=()
  local v
  for v in "${nums[@]}"; do
    if [[ -n "${seen[$v]:-}" ]]; then
      continue
    fi
    seen[$v]=1
    real_idx+=( "${idx_map[$v]}" )
  done

  # stdout: JSON index ë“¤ì„ í•œ ì¤„ì”© ë°˜í™˜
  printf '%s\n' "${real_idx[@]}"
}

##
# password ë°©ì‹ connection ëª©ë¡ì—ì„œ, ë¹„ë°€ë²ˆí˜¸(credential)ë¥¼ ì¼ê´„ ë³€ê²½í•  ëŒ€ìƒ ì¸ë±ìŠ¤ë“¤ì„ ì„ íƒí•œë‹¤.
# Select indices for bulk credential(password) update from password-based connections.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„ íƒ ì™„ë£Œ ì‹œ 0, ì·¨ì†Œ/ì‹¤íŒ¨ ì‹œ ë¹„-0 / 0 on success; non-zero on cancel/failure.
# @return {string} STDOUTë¡œ JSON index(__idx) ëª©ë¡ì„ í•œ ì¤„ì”© ì¶œë ¥ / prints JSON indices (__idx) one per line.
##
select_indices_for_modify_credential() {
  local query="$1"

  ensure_config_file
  local filter
  filter="$(build_search_filter "$query")"

  local raw
  raw="$(jq -r '
    .connections
    | to_entries
    | map(.key as $idx | .value + { "__idx": $idx })
    | map(select(('"$filter"') and (.auth_type == "password")))
    | sort_by([ (if .group == "default" then 0 else 1 end), .group, .name ])
    | .[]
    | "\(.group)\t\(.name)\t\(.host)\t\(.port // 22)\t\(.username)\t\(.credential)\t\(.__idx)"
  ' "$CONFIG_FILE")"

  if [[ -z "$raw" ]]; then
    echo "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. (password ë°©ì‹ connectionì´ ì—†ìŠµë‹ˆë‹¤.)" >&2
    return 1
  fi

  local idx_map=()
  local n=0 group name host port user cred idx
  local user_dec cred_dec display_cred

  if command -v column >/dev/null 2>&1; then
    local temp_buffer=""
    temp_buffer+="#\tGroup\tName\tHost\tPort\tUser\tCredential\n"

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"      

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      temp_buffer+="${display_idx}\t${group}\t${name}\t${host}\t${port}\t${user_dec}\t${cred_dec}\n"
    done <<< "$raw"

    local rendered header_line data_lines header_len dash_line eq_line
    rendered="$(printf "%b" "$temp_buffer" | column -t -s $'\t')"
    header_line="$(printf '%s\n' "$rendered" | head -n 1)"
    data_lines="$(printf '%s\n' "$rendered" | tail -n +2)"
    header_len=${#header_line}
    printf -v dash_line '%*s' "$header_len" ''
    dash_line="${dash_line// /-}"
    printf -v eq_line '%*s' "$header_len" ''
    eq_line="${eq_line// /=}"

    printf '%s\n' "$eq_line"     >&2
    printf '%s\n' "$header_line" >&2
    printf '%s\n' "$dash_line"   >&2
    printf '%s\n' "$data_lines"  >&2
    printf '%s\n' "$eq_line"     >&2
  else
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "#" "Group" "Name" "Host" "Port" "User" "Credential" >&2
    printf -- "%-4s\t%s\t%s\t%s\t%s\t%s\t%s\n" "----" "-----" "----" "----" "----" "----" "----------" >&2

    while IFS=$'\t' read -r group name host port user cred idx; do
      if [[ -z "$group" && -z "$name" && -z "$host" && -z "$port" && -z "$user" && -z "$cred" ]]; then
        continue
      fi

      user_dec="$(decrypt_value_if_needed "$user")"
      cred_dec="$(decrypt_value_if_needed "$cred")"
      display_cred="$(format_credential_for_display "$cred_dec")"

      n=$((n+1))
      idx_map[$n]="$idx"

      local display_idx
      printf -v display_idx "%04d" "$n"
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$display_idx" "$group" "$name" "$host" "$port" "$user_dec" "$display_cred" >&2
    done <<< "$raw"
  fi

  local sel
  while true; do
    read -r -p "â“  ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•  ë²ˆí˜¸(#)ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì½¤ë§ˆ(,)ë¡œ êµ¬ë¶„í•´ì„œ ì…ë ¥) [1 ~ $n] : " sel
    sel="${sel//[[:space:]]/}"

    if [[ -z "$sel" ]]; then
      echo "â—  í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." >&2
      return 1
    fi

    if ! [[ "$sel" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
      echo "ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ìˆ«ìë§Œ ì…ë ¥í•˜ì„¸ìš”." >&2
      continue
    fi

    local -a nums=()
    IFS=',' read -r -a nums <<< "$sel"

    local ok=true
    local v
    for v in "${nums[@]}"; do
      if (( v < 1 || v > n )); then
        echo "ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: $v (1~$n)" >&2
        ok=false
      fi
    done
    $ok && break
  done

  local -A seen=()
  local -a real_idx=()
  local v
  for v in "${nums[@]}"; do
    if [[ -n "${seen[$v]:-}" ]]; then
      continue
    fi
    seen[$v]=1
    real_idx+=( "${idx_map[$v]}" )
  done

  printf '%s\n' "${real_idx[@]}"
}

##
# sshctl -d|--delete-connection [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì„ ì‚­ì œí•œë‹¤.
# Implement sshctl -d|--delete-connection [expr] and delete a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì‚­ì œ ì™„ë£Œ ì‹œ 0, ì„ íƒ/í™•ì¸/ì €ì¥ ì‹¤íŒ¨ ë˜ëŠ” ì·¨ì†Œ ì‹œ ë¹„-0
#         0 on successful deletion; non-zero on failure or cancel.
##
cmd_delete_connection() {
  ensure_config_file

  local query="${1:-}"

  # 1) ì‚­ì œ ëŒ€ìƒ index (JSON ìƒì˜ __idx) ëª©ë¡ ì–»ê¸°
  local -a idxs=()
  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    idxs+=( "$line" )
  done < <(select_indices_for_delete "$query") || return 1

  if (( ${#idxs[@]} == 0 )); then
    #echo "ì„ íƒëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤." >&2
    return 1
  fi

  # 2) "ì‚­ì œ ëŒ€ìƒ:" ë¯¸ë¦¬ë³´ê¸°
  echo "ì‚­ì œ ëŒ€ìƒ:"
  local preview_raw=""
  local idx
  for idx in "${idxs[@]}"; do
    local row
    row="$(jq -r --argjson i "$idx" '
      .connections
      | to_entries
      | .[$i]
      | "\(.value.group)\t\(.value.name)\t\(.value.host)\t\(.value.port // 22)\t\(.value.username)\t\(.value.credential)"
    ' "$CONFIG_FILE")"
    if [[ -n "$row" ]]; then
      preview_raw+="${row}"$'\n'
    fi
  done
  print_raw_as_table_no_index "$preview_raw"

  # 3) ìµœì¢… í™•ì¸
  local answer
  read -r -p "ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " answer
  case "$answer" in
    y|Y|yes|YES)
      # 4) í° indexë¶€í„° ì‚­ì œ (ì•ìª½ index ì˜í–¥ ìµœì†Œí™”)
      local sorted
      sorted="$(printf '%s\n' "${idxs[@]}" | sort -rn)"

      local i
      for i in $sorted; do
        local selected_json
        selected_json="$(jq -c --argjson j "$i" '
          .connections
          | to_entries
          | .[$j]
          | { __idx: .key } + .value
        ' "$CONFIG_FILE")" || continue

        local new_json
        new_json="$(update_connection_delete "$selected_json")"
        save_connections_json <<< "$new_json"
      done

      echo "ì‚­ì œ ì™„ë£Œ."
      ;;
    *)
      echo "ì‚­ì œ ì·¨ì†Œ."
      ;;
  esac
}

##
# sshctl -mg|--move-group [expr] ëª…ë ¹ì„ êµ¬í˜„í•˜ì—¬ ì„ íƒëœ connectionì˜ groupì„ ë³€ê²½í•œë‹¤.
# Implement sshctl -mg|--move-group [expr] and change the group of a selected connection.
#
# @param $1 {string|empty} query ê²€ìƒ‰ì‹, ë¹„ì–´ ìˆìœ¼ë©´ ì „ì²´ / search expression; empty for all
#
# @return {int} ì„±ê³µ ì‹œ 0, ì„ íƒ/ê²€ì¦/ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¹„-0
#         0 on success; non-zero on selection/validation/save failures.
##
cmd_move_group_connection() {
  ensure_config_file

  local query="${1:-}"
  local selected_json
  selected_json="$(select_connection_interactively "$query")" || return 1

  echo "-----------------------------------------------------------"

  local current_group idx
  current_group="$(jq -r '.group' <<< "$selected_json")"
  idx="$(jq -r '.__idx'  <<< "$selected_json")"

  echo "í˜„ì¬ group: ${current_group}"

  local new_group
  while true; do
    new_group="$(prompt_with_icon "ğŸ“" "ìƒˆ group" "$current_group")"
    if [[ -z "$new_group" ]]; then
      new_group="$current_group"
    fi
    if validate_non_empty "group" "$new_group"; then
      break
    fi
  done

  echo "-----------------------------------------------------------"

  local new_json
  new_json="$(update_connection_move_group "$selected_json" "$new_group")"
  save_connections_json <<< "$new_json"

  echo "group ë³€ê²½ ì™„ë£Œ: ${current_group} â†’ ${new_group}"
  echo "ë³€ê²½ëœ connection:"

  local updated_json
  updated_json="$(jq -c --argjson i "$idx" '
    .connections
    | to_entries
    | .[$i]
    | { __idx: .key } + .value
  ' "$CONFIG_FILE")"
  print_connection_preview_from_json "$updated_json"
}

# =======================================
# main
# =======================================

##
# sshctl ì—”íŠ¸ë¦¬í¬ì¸íŠ¸ í•¨ìˆ˜ë¡œ, ì „ì—­ ì˜µì…˜ê³¼ ì„œë¸Œì»¤ë§¨ë“œë¥¼ íŒŒì‹±í•˜ê³  ê° ëª…ë ¹ì„ ë””ìŠ¤íŒ¨ì¹˜í•œë‹¤.
# Entry point for sshctl; parses global options and subcommands, then dispatches to handlers.
#
# @param $1..$n {string} CLI ì¸ì (ì˜ˆ: --config, -l, -a, -m ë“±) / CLI arguments (e.g. --config, -l, -a, -m)
#
# @return {int} ê° cmd_* í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ì½”ë“œ ë˜ëŠ” die() í˜¸ì¶œ ì‹œ exit 1
#         Exit code from the corresponding cmd_* function or 1 via die().
##
main() {
  ensure_dependencies

  # ê¸°ë³¸ê°’
  SHOW_CREDENTIAL="false"
  EXEC_CMD="connect"

  CONNECT_NUMBER=""

  local arg_config=""
  local arg_masterkey=""
  local show_help="false"
  local -a positional_args=()

  # 0) ì „ì—­ ì˜µì…˜ íŒŒì‹±
  #    - --config <path>
  #    - -s / --show-credential
  #    - -h / --help
  #    â†’ ì¸ì ì „ì²´ë¥¼ í›‘ìœ¼ë©´ì„œ ì²˜ë¦¬í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” positional_args ì—ë§Œ ëª¨ì€ë‹¤.
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --config)
        shift || true
        if [[ $# -eq 0 ]]; then
          echo "[ERROR] --config ì˜µì…˜ì—ëŠ” ì„¤ì • íŒŒì¼ ê²½ë¡œê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
          exit 1
        fi
        arg_config="$1"
        shift
        ;;
      --masterkey)
        shift || true
        if [[ $# -eq 0 ]]; then
          echo "[ERROR] --masterkey ì˜µì…˜ì—ëŠ” masterkey(OpenSSH private key) íŒŒì¼ ê²½ë¡œê°€ í•„ìš”í•©ë‹ˆë‹¤." >&2
          exit 1
        fi
        arg_masterkey="$1"
        shift
        ;;
      -s|--show-credential)
        SHOW_CREDENTIAL="true"
        shift
        ;;
      -n|--number)
        shift || true
        if [[ $# -eq 0 ]]; then
          echo "[ERROR] --number|-n ì˜µì…˜ì—ëŠ” ìˆ«ì ê°’ì´ í•„ìš”í•©ë‹ˆë‹¤." >&2
          exit 1
        fi
        if ! [[ "$1" =~ ^[0-9]+$ ]]; then
          echo "[ERROR] --number|-n ê°’ì€ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤: $1" >&2
          exit 1
        fi
        if [[ -n "${CONNECT_NUMBER:-}" ]]; then
          echo "[ERROR] --number|-n ì˜µì…˜ì€ 1íšŒë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." >&2
          exit 1
        fi
        CONNECT_NUMBER="$1"
        shift
        ;;
      -h|--help)
        show_help="true"
        shift
        ;;
      --)
        shift
        # '--' ì´í›„ëŠ” ëª¨ë‘ ìˆœìˆ˜ ì¸ìë¡œ ì „ë‹¬
        while [[ $# -gt 0 ]]; do
          positional_args+=("$1")
          shift
        done
        break
        ;;
      *)
        # ì „ì—­ ì˜µì…˜ì´ ì•„ë‹Œ ëª¨ë“  ì¸ìëŠ” ê·¸ëŒ€ë¡œ positional ì˜ì—­ì— ìŒ“ëŠ”ë‹¤.
        positional_args+=("$1")
        shift
        ;;
    esac
  done

  # ì „ì—­ ì˜µì…˜ì„ ì œê±°í•œ ë‚˜ë¨¸ì§€ ì¸ìë¥¼ ë³µì›
  if [[ ${#positional_args[@]} -gt 0 ]]; then
    set -- "${positional_args[@]}"
  else
    set --
  fi

  # -h / --help ê°€ í•œ ë²ˆì´ë¼ë„ ë“±ì¥í–ˆìœ¼ë©´, ë‚˜ë¨¸ì§€ ì¸ìì™€ ë¬´ê´€í•˜ê²Œ ë„ì›€ë§ ì¶œë ¥
  if [[ "$show_help" == "true" ]]; then
    help ""
    return 0
  fi

  # CONFIG_FILE ìš°ì„ ìˆœìœ„
  #  1) --config
  #  2) SSH_CMD_CONFIG í™˜ê²½ë³€ìˆ˜
  #  3) DEFAULT_CONFIG_FILE
  if [[ -n "$arg_config" ]]; then
    CONFIG_FILE="$arg_config"
  elif [[ -n "${SSH_CMD_CONFIG:-}" ]]; then
    CONFIG_FILE="${SSH_CMD_CONFIG}"
  fi

  # MASTERKEY_FILE ìš°ì„ ìˆœìœ„
  #  1) --masterkey
  #  2) SSH_CMD_MASTERKEY
  #  3) SSM_CMD_MASTERKEY (ì˜¤íƒ€/í˜¸í™˜ìš© ë³„ì¹­)
  #  4) MASTERKEY_DEFAULT
  if [[ -n "$arg_masterkey" ]]; then
    MASTERKEY_FILE="$arg_masterkey"
  elif [[ -n "${SSH_CMD_MASTERKEY:-}" ]]; then
    MASTERKEY_FILE="${SSH_CMD_MASTERKEY}"
  elif [[ -n "${SSM_CMD_MASTERKEY:-}" ]]; then
    MASTERKEY_FILE="${SSM_CMD_MASTERKEY}"
  fi

  # ì„¤ì • íŒŒì¼ ê²€ì¦
  ensure_config_file
  # open ssh key md5 ê²€ì¦
  ensure_masterkey_md5

  # ë‚¨ì€ ì¸ìê°€ ì—†ìœ¼ë©´: sshctl [Enter] â†’ connect (masking list)
  if [[ $# -eq 0 ]]; then
    EXEC_CMD="connect"
    cmd_connect ""
    return 0
  fi

  local first="$1"

  # -n|--number ëŠ” connect ì „ìš© ì˜µì…˜ì´ë©°, ëª¨ë“œ ì˜µì…˜ê³¼ëŠ” ìƒí˜¸ë°°íƒ€ì ì…ë‹ˆë‹¤.
  if [[ -n "${CONNECT_NUMBER:-}" ]]; then
    case "$first" in
      --list|-l|--list-all|--add-connection|-a|--modify-connection|-m|--delete-connection|-d|--move-group|-mg|--modify-credential|-mc)
        echo "[ERROR] --number|-n ì˜µì…˜ì€ ì ‘ì†(connect) ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." >&2
        echo "        (ë‹¤ë¥¸ ëª¨ë“œ ì˜µì…˜ê³¼ëŠ” í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.)" >&2
        exit 1
        ;;
    esac
  fi

  # ì„¤ì • ë° ë³´ì•ˆ ì •ë³´ ê¸°ë³¸ ë…¸ì¶œ
  print_config_summary_banner

  # 1) ì–´ë–¤ ì„œë¸Œì»¤ë§¨ë“œë¥¼ ì‹¤í–‰í• ì§€ ê²°ì •
  case "$first" in
    --list|-l|--list-all)
      # [ì—°ê²°ì •ë³´ ëª©ë¡] ëª¨ë“œ
      EXEC_CMD="list"
      shift
      # ë‚¨ì€ ì²« ë²ˆì§¸ ì¸ìë¥¼ ê²€ìƒ‰ì‹(<expr>) ìœ¼ë¡œ ì‚¬ìš© (ì—†ìœ¼ë©´ ì „ì²´)
      cmd_list "${1:-}"
      ;;
    --add-connection|-a)
      # [ì—°ê²°ì •ë³´ ì¶”ê°€]
      EXEC_CMD="add"
      shift
      cmd_add_connection
      ;;
    --modify-connection|-m)
      # [ì—°ê²°ì •ë³´ ìˆ˜ì •] - plain list ì‚¬ìš©, -s ì˜µì…˜ì€ ì „ì—­ ì˜µì…˜ìœ¼ë¡œë§Œ ì²˜ë¦¬(í‘œì‹œ ë°©ì‹ì—ëŠ” ì˜í–¥ ì—†ìŒ)
      EXEC_CMD="modify"
      shift
      cmd_modify_connection "${1:-}"
      ;;
    --delete-connection|-d)
      # [ì—°ê²°ì •ë³´ ì‚­ì œ] - masking list ê³ ì •, -s ì˜µì…˜ ë¬´ì‹œ
      EXEC_CMD="delete"
      shift
      cmd_delete_connection "${1:-}"
      ;;
    --move-group|-mg)
      # [ì—°ê²°ì •ë³´ ê·¸ë£¹ ì´ë™] - masking list ê³ ì •, -s ì˜µì…˜ ë¬´ì‹œ
      EXEC_CMD="move-group"
      shift
      cmd_move_group_connection "${1:-}"
      ;;
    --modify-credential|-mc)
      # [ë¹„ë°€ë²ˆí˜¸ ì¼ê´„ë³€ê²½] - password ë°©ì‹ connectionë§Œ ëŒ€ìƒìœ¼ë¡œ credential ì¼ê´„ ë³€ê²½, -s ì˜µì…˜ì€ ì „ì—­ ì˜µì…˜ìœ¼ë¡œ ì ìš©
      EXEC_CMD="modify-credential"
      shift
      cmd_modify_credential "${1:-}"
      ;;
    --version)
      echo "sshctl version ${APP_VERSION:-unknown}"
      return 0
      ;;
    -*)
      # ì¸ì‹ë˜ì§€ ì•ŠëŠ” ì˜µì…˜
      echo "Unknown option or command: $first" >&2
      exit 1
      ;;
    *)
      # ë‚˜ë¨¸ì§€ëŠ” ëª¨ë‘ [ì„œë²„ ì ‘ì†]ìœ¼ë¡œ ì²˜ë¦¬
      #   sshctl <expr> â†’ <expr> ê²€ìƒ‰ê²°ê³¼ê°€ ì ìš©ëœ masking list ê¸°ë°˜ ì ‘ì†
      EXEC_CMD="connect"
      cmd_connect "$first"
      ;;
  esac
}

main "$@"

exit 0