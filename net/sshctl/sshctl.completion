# =======================================
# @author   : parkjunhong77@gmail.com
# @title    : sshctl bash completion.
# @license  : Apache License 2.0
# @since    : 2025-12-15
# @desc     : support RHEL 7+/Oracle Linux 7+/Ubuntu 20.04+/CentOS 7+
# @installation :
#   1. insert 'source <path>/sshctl.completion" into ~/bin/.bashrc or ~/bin/.bash_profile for a personal usage.
#   2. copy the above file to /etc/bash_completion.d/ or insert 'source <path>/sshctl.completion' into
#      /etc/bashrc for all users.
# =======================================

# =======================================
# Global Reserved Variables
# 1. COMP_WORDS: an array, contains all arguments
# 2. COMP_CWORD: a index of a cursor
# 3. COMP_LINE: all command string
# 4. COMPREPLY: an array, contains suggested words. words are sorted and unique.
#
# Arguments of a function
# 1. $1: command
# 2. $2: current
# 3. $3: previous
#
# e.g.: mycmd arg1 arg2 arg3 arg4[tab]
# - $1: mycmd
# - $2: arg4
# - $3: arg3
# =======================================

# sshctl completion
# - 한국어: sshctl 명령에 대한 bash 자동 완성 지원
# - English: bash completion support for sshctl command
#
# 지원 내용 / Features:
# - long/short 옵션 자동 완성:
#   * --add-connection | -a
#   * --modify-connection | -m
#   * --delete-connection | -d
#   * --move-group-connection | -mg
#   * --list-all | -l
#   * --config
#   * --masterkey
#   * --show-credential | -s
#   * --help | -h
# - 기능 옵션(모드 옵션)은 상호 배타적이며 한 번만 사용 가능
#   * mutual exclusive mode options:
#     --add-connection|-a, --modify-connection|-m,
#     --delete-connection|-d, --move-group-connection|-mg,
#     --list-all|-l
# - 전역 옵션(--config, --masterkey, --help/-h)은 항상 사용 가능하지만,
#   * 동일 옵션(동일 역할의 long/short 쌍 포함)이 이미 사용된 경우 다시 제안하지 않음
# - --show-credential / -s 옵션은 '--list-all' / '-l' 또는 '--modify-connection' / '-m' 이 사용된 경우에만 제안
# - --config, --masterkey 옵션 뒤에서는 파일/경로 자동 완성
# - sshctl [TAB] 으로도 즉시 옵션을 추천
# - 비옵션(검색어/expr 자리)에서는 설정 파일(configuration)의 connection.name 기반 자동 완성
#   * 기본 설정 파일: ${HOME}/.sshctl/configuration.conf
#   * --config <file> 가 있으면 해당 파일 우선
#   * jq 가 없거나 파일이 없으면 조용히 무시 (완성 없음)
#   * username/credential 등 민감정보는 절대 읽지 않고, name 필드만 사용

_sshctl_completion() {
  local cmd cur prev
  cmd="$1"
  cur="$2"
  prev="$3"

  # --- Mode Options (mutual exclusive; long+short) ---
  # 상호 배타적 모드 옵션: 한 번만 사용 가능
  local mode_opts_all=(
    --add-connection
    --modify-connection
    --delete-connection
    --move-group-connection
    --list-all
    -a
    -m
    -d
    -mg
    -l
  )

  # --- Global options (unique; long+short) ---
  # 전역 옵션: 항상 사용 가능하나, 동일 역할 옵션은 1회만
  local global_opts_all=(
    --config
    --masterkey
    --help
    -h
  )

  # --- Sub option: only valid when list-all/-l is used ---
  # --list-all/-l 사용 시에만 의미 있는 옵션
  local list_sub_opts_all=(
    --show-credential
    -s
  )

  # --------------------------------------
  # STEP 1: prev 가 파일/경로 값을 기대하는 옵션인지 확인
  #         If previous token expects a file/dir path
  # --------------------------------------
  case "$prev" in
    --config|--masterkey)
      COMPREPLY=( $(compgen -f -- "$cur") )
      return 0
      ;;
  esac

  # --------------------------------------
  # STEP 2: 이미 사용된 옵션들 수집
  #         detect used mode/global/sub options
  # --------------------------------------
  local mode_used=0
  local listall_used=0
  local modify_used=0

  local used_config=0
  local used_masterkey=0
  local used_help=0

  local used_show_credential=0

  local w
  for w in "${COMP_WORDS[@]:1}"; do
    case "$w" in
      # 모드 옵션 (long/short)
      --add-connection|-a|\
      --modify-connection|-m|\
      --delete-connection|-d|\
      --move-group-connection|-mg|\
      --list-all|-l)
        mode_used=1
        [[ "$w" == "--list-all" || "$w" == "-l" ]] && listall_used=1
        [[ "$w" == "--modify-connection" || "$w" == "-m" ]] && modify_used=1
        ;;
      # 전역 옵션 (long/short)
      --config)
        used_config=1
        ;;
      --masterkey)
        used_masterkey=1
        ;;
      --help|-h)
        used_help=1
        ;;
      # sub option (long/short)
      --show-credential|-s)
        used_show_credential=1
        ;;
    esac
  done

  # --------------------------------------
  # STEP 3: 추천 후보(candidates) 구성
  #         build candidate list
  # --------------------------------------
  local candidates=()

  # (A) Mode options: 아무 모드도 아직 선택되지 않은 경우에만 제안
  #     suggest all mode options (long+short) only when none is used yet
  if (( mode_used == 0 )); then
    candidates+=( "${mode_opts_all[@]}" )
  fi

  # (B) Global options: 항상 가능하되, 이미 사용된 것은 제외
  #     global options: always allowed but unique (per role)
  if (( used_config == 0  )); then
    candidates+=( --config )
  fi
  if (( used_masterkey == 0 )); then
    candidates+=( --masterkey )
  fi
  if (( used_help == 0 )); then
    candidates+=( --help -h )
  fi

  # (C) Sub option (--show-credential / -s):
  #     --list-all/-l 또는 --modify-connection/-m 이 이미 사용되었고, 아직 show-credential/-s 가 없을 때만 제안
  if (( (listall_used == 1 || modify_used == 1) && used_show_credential == 0 )); then
    candidates+=( "${list_sub_opts_all[@]}" )
  fi

  # --------------------------------------
  # STEP 4: 옵션 자동완성 트리거 규칙
  #         when to propose option candidates
  # --------------------------------------
  # 1) cur 이 비어있을 때 (sshctl [TAB])
  # 2) cur 이 '-' 로 시작할 때 (sshctl -[TAB], sshctl --[TAB])
  if [[ -z "$cur" || "$cur" == -* ]]; then
    COMPREPLY=( $(compgen -W "${candidates[*]}" -- "$cur") )
    return 0
  fi

  # --------------------------------------
  # STEP 5: 비옵션(검색어/expr) 자리에서는 connection name 자동 완성
  #         when current token is not an option, complete using connection.name
  # --------------------------------------
  # 기본 설정 파일: ~/.sshctl/configuration.conf
  local config_file
  config_file="${HOME}/.sshctl/configuration.conf"

  # --config <file> 가 있으면 해당 파일 우선
  # find last --config and use its argument as config_file
  local i
  for (( i=1; i < ${#COMP_WORDS[@]}-1; i++ )); do
    if [[ "${COMP_WORDS[i]}" == "--config" ]]; then
      local cfg="${COMP_WORDS[i+1]}"
      # '-' 로 시작하면 옵션으로 보고 무시
      if [[ -n "$cfg" && "$cfg" != -* ]]; then
        config_file="$cfg"
      fi
    fi
  done

  # ~ 확장 (아주 단순하게 앞자리만 처리)
  if [[ "$config_file" == "~/"* ]]; then
    config_file="${HOME}${config_file:1}"
  fi

  # jq 가 있고, 설정 파일이 읽기 가능하면 connections[].name 목록을완성 후보로 사용
  if command -v jq >/dev/null 2>&1 && [[ -r "$config_file" ]]; then
    local names=()
    # 민감정보는 절대 읽지 않고, name 필드만 사용
    while IFS= read -r line; do
      [[ -n "$line" ]] && names+=( "$line" )
    done < <(jq -r '.connections[]?.name // empty' "$config_file" 2>/dev/null)

    if (( ${#names[@]} > 0 )); then
      COMPREPLY=( $(compgen -W "${names[*]}" -- "$cur") )
      return 0
    fi
  fi

  # connection name 후보도 없으면 완성 없음
  COMPREPLY=()
  return 0
}

# bash-completion v1 스타일 래퍼
# Wrapper for bash-completion v1 style
_sshctl() {
  local cur prev
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  _sshctl_completion "sshctl" "$cur" "$prev"
}

# 실제 sshctl 명령과 연결
# Bind completion function to sshctl command
complete -F _sshctl sshctl